<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Analytical · MaxEntropyGraphs.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.jpeg" alt="MaxEntropyGraphs.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">MaxEntropyGraphs.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Models</span><ul><li><a class="tocitem" href="../models/">Overview</a></li><li><a class="tocitem" href="../models/UBCM/">UBCM</a></li><li><a class="tocitem" href="../models/DBCM/">DBCM</a></li><li><a class="tocitem" href="../models/BiCM/">BiCM</a></li></ul></li><li><span class="tocitem">Metrics</span><ul><li><a class="tocitem" href="../metrics/">Overview</a></li><li class="is-active"><a class="tocitem" href>Analytical</a><ul class="internal"><li><a class="tocitem" href="#Expected-value"><span>Expected value</span></a></li><li><a class="tocitem" href="#Variance"><span>Variance</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li></ul></li><li><a class="tocitem" href="../simulated/">Simulation</a></li></ul></li><li><a class="tocitem" href="../GPU/">GPU acceleration</a></li><li><a class="tocitem" href="../API/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Metrics</a></li><li class="is-active"><a href>Analytical</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Analytical</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/main/docs/src/exact.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Analytical"><a class="docs-heading-anchor" href="#Analytical">Analytical</a><a id="Analytical-1"></a><a class="docs-heading-anchor-permalink" href="#Analytical" title="Permalink"></a></h1><p>The maximum likelihood method can be used to compute the expected value and the standard deviation of any metric that is based on the adjacency matrix. Depending on the underlying model, some details change, but the principle remains. This formalism allows us to computed z-scores and assess which topological properties are consistent with their randomized value within a statistical error, and which deviate significantly from the null model expectation. In the latter case, the observed property cannot be traced back to the constraints, and therefore requires additional explanations or generating mechanisms besides those required in order to explain the constraints themselves. </p><p>Some topological properties are available in the package default (e.g. <code>ANND</code> and different network motifs), but you can define an additional metrics as well. This allows you to obtain both the expected value and the standard deviation of any matrix in a standardised way. In the expression of the variance of a topological property <span>$X$</span>, we find <span>$\frac{\partial X}{\partial a_{ij}}$</span>. We use leverage Julia&#39;s autodiff capabilities to compute these terms. If desired, you can always compute the gradient of a specific metric by hand and implement it yourself as well. The downside of using this approach is that you need the complete adjacency matrix, so this is not suited for the analysis of very large graphs due to memory constraints. Depending on the size of the problem, different autodiff techniques can give different performance results. You might want to experiment a bit with this for your own use case (some examples are provided as well).  </p><h2 id="Expected-value"><a class="docs-heading-anchor" href="#Expected-value">Expected value</a><a id="Expected-value-1"></a><a class="docs-heading-anchor-permalink" href="#Expected-value" title="Permalink"></a></h2><p>Using the maximum likelihood method method the expected value for any topological property <code>X</code> can be computed from the expected values in the adjacency matrix of the graph <code>G</code> (this approximation ignores the second and higher order terms in the multidimensional Taylor expansion of <code>X</code>).</p><p class="math-container">\[X \left( G \right)  =  X \left( \left&lt; G \right&gt; \right)\]</p><h2 id="Variance"><a class="docs-heading-anchor" href="#Variance">Variance</a><a id="Variance-1"></a><a class="docs-heading-anchor-permalink" href="#Variance" title="Permalink"></a></h2><p>The variance of a topological property <code>S</code> can be written as follows</p><p class="math-container">\[\sigma ^{2} \left[ X \right] = \sum_{i,j} \sum_{t,s} \sigma \left[g_{ij}, g_{ts} \right] \left(  \frac{\partial X}{\partial g_{ij}} \frac{\partial X}{\partial g_{ts}}  \right)_{G = \left&lt; G \right&gt;}\]</p><p>where</p><p class="math-container">\[\sigma \left[ g_{ij}, g_{ts} \right] = \left&lt; g_{ij}g_{ts}\right&gt; - \left&lt; g_{ij}\right&gt;\left&lt; g_{ts}\right&gt;\]</p><p>Using the appropriate expressions for  <span>$\left&lt; g_{ij} \right&gt;$</span> and <span>$\left&lt; g_{ij}\right&gt;$</span> (depending on the model considered, cf. examples), a highly reliable estimate for the variance of the metric can be obtained.</p><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><p>Some examples using built-in function of package are listed below:</p><ul><li><a href="#Assortativity_analytical">Assortativity in the UBCM</a></li><li><a href="#Motif_analytical">Motif significance in the UBCM</a></li></ul><h3 id="Assortativity_analytical"><a class="docs-heading-anchor" href="#Assortativity_analytical">Assortativity in the UBCM</a><a id="Assortativity_analytical-1"></a><a class="docs-heading-anchor-permalink" href="#Assortativity_analytical" title="Permalink"></a></h3><p>Let us consider the UBCM applied to the Zachary Karate Club network. We want to analyse if the assortativity of each node (measured by its ANND) is statistically significant from what one would expect under the null model.</p><p>First, we define the network and the associated UBCM model.</p><pre><code class="language-julia hljs">using Graphs
using MaxEntropyGraphs

# define the network
G = MaxEntropyGraphs.Graphs.SimpleGraphs.smallgraph(:karate)
# generate a UBCM model from the karate club network
model = UBCM(G); 
# compute the maximum likelihood parameters
solve_model!(model); 
# compute and set the expected adjacency matrix
set_Ĝ!(model); 
# compute and set the standard deviation of the adjacency matrix
set_σ!(model); 
nothing</code></pre><p>Now we can define our specific metric. Before computing the z-score for all nodes, we illustrate the process for a single node. We use <code>X</code> as variable name for our metric. Defining methods for <code>X</code> in such a way that it can   with both an <code>AbstractArray</code> and an <code>AbstractGraph</code> is recommended, but not necessary.</p><pre><code class="language-julia hljs"># We consider the ANND of node 1 as our metric
node_id = 1
X = A -&gt; ANND(A, node_id, check_dimensions=false, check_directed=false);    
# Expected value under the null model
X_expected = X(model.Ĝ)
# Expected standard deviation under the null model
X_std = σₓ(model, X)
# Observed value (using the underlying network)
X_observed = X(model.G)
# compute z-score
z_X = (X_observed - X_expected) / X_std</code></pre><p>In the same way, we can compute the z-score for every node:</p><pre><code class="language-julia hljs"># Observed value
ANND_obs = [ANND(G, i) for i in vertices(G)]
# Expected values
ANND_exp = [ANND(model.Ĝ, i) for i in vertices(G)]
# Standard deviation
ANND_std = [σₓ(model, A -&gt; ANND(A, i, check_dimensions=false, check_directed=false)) for i in vertices(G)]
# Z-score
Z_ANND = (ANND_obs - ANND_exp) ./ ANND_std;</code></pre><h3 id="Motif_analytical"><a class="docs-heading-anchor" href="#Motif_analytical">Motif significance in the UBCM</a><a id="Motif_analytical-1"></a><a class="docs-heading-anchor-permalink" href="#Motif_analytical" title="Permalink"></a></h3><p>Let us consider the DBCM applied to the Chesapeake Bay foodweb. We want to analyse if any of the different network motifs is statistically significant of what one would expect uner the null model.</p><p>First, we define the network and the associated UBCM model.</p><pre><code class="language-julia hljs">using Graphs
using MaxEntropyGraphs
import Statistics: mean, std

# define the network
G = chesapeakebay()
# extract its adjacency matrix
A = adjacency_matrix(G)
# generate a UBCM model from the karate club network
model = DBCM(G); 
# compute the maximum likelihood parameters
solve_model!(model); 
# compute and set the expected adjacency matrix
set_Ĝ!(model); 
# compute and set the standard deviation of the adjacency matrix
set_σ!(model); 
nothing</code></pre><p>We want to know the values of <code>M1</code>, ..., <code>M13</code>. These are network-wide measures. </p><pre><code class="language-julia hljs"># compute the observed motif counts
motifs_observed = [@eval begin $(f)(A) end for f in MaxEntropyGraphs.directed_graph_motif_function_names];
# Expected value under the null model
motifs_expected = [@eval begin $(f)(model) end for f in MaxEntropyGraphs.directed_graph_motif_function_names];
# Expected standard deviation under the null model
motifs_std = [@eval begin  σₓ(model, $(f), gradient_method=:ForwardDiff) end for f in MaxEntropyGraphs.directed_graph_motif_function_names];
# compute the z-score
motifs_z = (motifs_observed .- motifs_expected) ./ motifs_std</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../metrics/">« Overview</a><a class="docs-footer-nextpage" href="../simulated/">Simulation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 29 September 2023 14:12">Friday 29 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
