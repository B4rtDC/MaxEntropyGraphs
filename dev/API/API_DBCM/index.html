<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DBCM · MaxEntropyGraphs.jl</title><meta name="title" content="DBCM · MaxEntropyGraphs.jl"/><meta property="og:title" content="DBCM · MaxEntropyGraphs.jl"/><meta property="twitter:title" content="DBCM · MaxEntropyGraphs.jl"/><meta name="description" content="Documentation for MaxEntropyGraphs.jl."/><meta property="og:description" content="Documentation for MaxEntropyGraphs.jl."/><meta property="twitter:description" content="Documentation for MaxEntropyGraphs.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.jpeg" alt="MaxEntropyGraphs.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MaxEntropyGraphs.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Models</span><ul><li><a class="tocitem" href="../../models/">Overview</a></li><li><a class="tocitem" href="../../models/UBCM/">UBCM</a></li><li><a class="tocitem" href="../../models/DBCM/">DBCM</a></li><li><a class="tocitem" href="../../models/BiCM/">BiCM</a></li></ul></li><li><span class="tocitem">Metrics</span><ul><li><a class="tocitem" href="../../metrics/">Overview</a></li><li><a class="tocitem" href="../../exact/">Analytical</a></li><li><a class="tocitem" href="../../simulated/">Simulation</a></li></ul></li><li><a class="tocitem" href="../../GPU/">GPU acceleration</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../API/">Shared</a></li><li><a class="tocitem" href="../API_UBCM/">UBCM</a></li><li class="is-active"><a class="tocitem" href>DBCM</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="../API_BiCM/">BiCM</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>DBCM</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DBCM</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/main/docs/src/API/API_DBCM.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#MaxEntropyGraphs.DBCM-Tuple{T} where T"><code>MaxEntropyGraphs.DBCM</code></a></li><li><a href="#MaxEntropyGraphs.DBCM"><code>MaxEntropyGraphs.DBCM</code></a></li><li><a href="#Base.length-Tuple{DBCM}"><code>Base.length</code></a></li><li><a href="#Base.precision-Tuple{DBCM}"><code>Base.precision</code></a></li><li><a href="#Base.rand-Tuple{DBCM}"><code>Base.rand</code></a></li><li><a href="#Base.rand-Tuple{DBCM, Int64}"><code>Base.rand</code></a></li><li><a href="#MaxEntropyGraphs.A-Tuple{DBCM, Int64, Int64}"><code>MaxEntropyGraphs.A</code></a></li><li><a href="#MaxEntropyGraphs.AIC-Tuple{DBCM}"><code>MaxEntropyGraphs.AIC</code></a></li><li><a href="#MaxEntropyGraphs.AICc-Tuple{DBCM}"><code>MaxEntropyGraphs.AICc</code></a></li><li><a href="#MaxEntropyGraphs.BIC-Tuple{DBCM}"><code>MaxEntropyGraphs.BIC</code></a></li><li><a href="#MaxEntropyGraphs.DBCM_reduced_iter!"><code>MaxEntropyGraphs.DBCM_reduced_iter!</code></a></li><li><a href="#MaxEntropyGraphs.L_DBCM_reduced"><code>MaxEntropyGraphs.L_DBCM_reduced</code></a></li><li><a href="#MaxEntropyGraphs.f_DBCM-Tuple{DBCM}"><code>MaxEntropyGraphs.f_DBCM</code></a></li><li><a href="#MaxEntropyGraphs.initial_guess-Tuple{DBCM}"><code>MaxEntropyGraphs.initial_guess</code></a></li><li><a href="#MaxEntropyGraphs.set_xᵣ!-Tuple{DBCM}"><code>MaxEntropyGraphs.set_xᵣ!</code></a></li><li><a href="#MaxEntropyGraphs.set_yᵣ!-Tuple{DBCM}"><code>MaxEntropyGraphs.set_yᵣ!</code></a></li><li><a href="#MaxEntropyGraphs.set_Ĝ!-Tuple{DBCM}"><code>MaxEntropyGraphs.set_Ĝ!</code></a></li><li><a href="#MaxEntropyGraphs.set_σ!-Tuple{DBCM}"><code>MaxEntropyGraphs.set_σ!</code></a></li><li><a href="#MaxEntropyGraphs.solve_model!-Tuple{DBCM}"><code>MaxEntropyGraphs.solve_model!</code></a></li><li><a href="#MaxEntropyGraphs.Ĝ-Tuple{DBCM}"><code>MaxEntropyGraphs.Ĝ</code></a></li><li><a href="#MaxEntropyGraphs.σˣ-Tuple{DBCM}"><code>MaxEntropyGraphs.σˣ</code></a></li><li><a href="#MaxEntropyGraphs.σₓ-Tuple{DBCM, Function}"><code>MaxEntropyGraphs.σₓ</code></a></li><li><a href="#MaxEntropyGraphs.∇L_DBCM_reduced!"><code>MaxEntropyGraphs.∇L_DBCM_reduced!</code></a></li><li><a href="#MaxEntropyGraphs.∇L_DBCM_reduced_minus!"><code>MaxEntropyGraphs.∇L_DBCM_reduced_minus!</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.DBCM" href="#MaxEntropyGraphs.DBCM"><code>MaxEntropyGraphs.DBCM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DBCM</code></pre><p>Maximum entropy model for the Directed Binary Configuration Model (UBCM).</p><p>The object holds the maximum likelihood parameters of the model (θ) and optionally the expected adjacency matrix (G),  and the variance for the elements of the adjacency matrix (σ). All settings and other metadata are stored in the <code>status</code> field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/b608cc39a925907591eec3f681d82a56edb9cd4d/src/Models/DBCM.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.DBCM-Tuple{T} where T" href="#MaxEntropyGraphs.DBCM-Tuple{T} where T"><code>MaxEntropyGraphs.DBCM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DBCM(G::T; precision::N=Float64, kwargs...) where {T&lt;:Graphs.AbstractGraph, N&lt;:Real}
DBCM(;d_out::Vector{T}, d_in::Vector{T}, precision::Type{&lt;:AbstractFloat}=Float64, kwargs...)</code></pre><p>Constructor function for the <code>DBCM</code> type. </p><p>By default and dependng on the graph type <code>T</code>, the definition of in- and outdegree from <span>$Graphs.jl$</span> is applied.  If you want to use a different definition of degrees, you can pass vectors of degrees sequences as keyword arguments (<code>d_out</code>, <code>d_in</code>). If you want to generate a model directly from degree sequences without an underlying graph, you can simply pass the degree sequences as arguments (<code>d_out</code>, <code>d_in</code>). If you want to work from an adjacency matrix, or edge list, you can use the graph constructors from the <span>$JuliaGraphs$</span> ecosystem.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># generating a model from a graph
julia&gt; G = MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques())
{16, 111} directed simple Int64 graph
julia&gt; model = DBCM(G)
DBCM{Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Float64} (16 vertices, 15 unique degree pairs, 0.94 compression ratio)</code></pre><pre><code class="language-julia-repl hljs"># generating a model directly from a degree sequence
julia&gt; model = DBCM(d_out=MaxEntropyGraphs.Graphs.outdegree(G), d_in=MaxEntropyGraphs.Graphs.indegree(G))
DBCM{Nothing, Float64} (16 vertices, 15 unique degree pairs, 0.94 compression ratio)</code></pre><pre><code class="language-julia-repl hljs"># generating a model directly from a degree sequence with a different precision
julia&gt;  model = DBCM(d_out=MaxEntropyGraphs.Graphs.outdegree(G), d_in=MaxEntropyGraphs.Graphs.indegree(G), precision=Float32)
DBCM{Nothing, Float32} (16 vertices, 15 unique degree pairs, 0.94 compression ratio)</code></pre><pre><code class="language-julia-repl hljs"># generating a model from an adjacency matrix
julia&gt; A = [0 1 1;1 0 0;1 1 0];

julia&gt; G = MaxEntropyGraphs.Graphs.SimpleDiGraph(A)
{3, 5} directed simple Int64 graph
julia&gt; model = DBCM(G)
DBCM{Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Float64} (3 vertices, 3 unique degree pairs, 1.00 compression ratio)</code></pre><pre><code class="language-julia-repl hljs"># generating a model from an edge list
julia&gt; E = [(1,2),(1,3),(2,3)];

julia&gt; edgelist = [MaxEntropyGraphs.Graphs.Edge(x,y) for (x,y) in E];

julia&gt; G = MaxEntropyGraphs.Graphs.SimpleDiGraphFromIterator(edgelist)
{3, 3} directed simple Int64 graph
julia&gt; model = DBCM(G)
DBCM{Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Float64} (3 vertices, 3 unique degree pairs, 1.00 compression ratio)
</code></pre><p>See also <a href="https://juliagraphs.org/Graphs.jl/stable/core_functions/core/#Graphs.outdegree-Tuple{AbstractGraph,%20Integer}"><code>Graphs.outdegree</code></a>, <a href="https://juliagraphs.org/Graphs.jl/stable/core_functions/core/#Graphs.indegree-Tuple{AbstractGraph,%20Integer}"><code>Graphs.indegree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/b608cc39a925907591eec3f681d82a56edb9cd4d/src/Models/DBCM.jl#L54-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.solve_model!-Tuple{DBCM}" href="#MaxEntropyGraphs.solve_model!-Tuple{DBCM}"><code>MaxEntropyGraphs.solve_model!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve_model!(m::DBCM)</code></pre><p>Compute the likelihood maximising parameters of the DBCM model <code>m</code>. </p><p><strong>Arguments</strong></p><ul><li><code>method::Symbol</code>: solution method to use, can be <code>:fixedpoint</code> (default), or :NelderMead, :BFGS, :LBFGS and :Newton.</li><li><code>initial::Symbol</code>: initial guess for the parameters <span>$\Theta$</span>, can be :degrees (default), :degrees<em>minor, :random, :uniform, or :chung</em>lu.</li><li><code>maxiters::Int</code>: maximum number of iterations for the solver (defaults to 1000). </li><li><code>verbose::Bool</code>: set to show log messages (defaults to false).</li><li><code>ftol::Real</code>: function tolerance for convergence with the fixedpoint method (defaults to 1e-8).</li><li><code>abstol::Union{Number, Nothing}</code>: absolute function tolerance for convergence with the other methods (defaults to <code>nothing</code>).</li><li><code>reltol::Union{Number, Nothing}</code>: relative function tolerance for convergence with the other methods (defaults to <code>nothing</code>).</li><li><code>AD_method::Symbol</code>: autodiff method to use, can be any of :AutoZygote, :AutoReverseDiff, :AutoForwardDiff and :AutoFiniteDiff. Performance depends on the size of the problem (defaults to <code>:AutoZygote</code>),</li><li><code>analytical_gradient::Bool</code>: set the use the analytical gradient instead of the one generated with autodiff (defaults to <code>false</code>)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># default use
julia&gt; model = DBCM(MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques()));

julia&gt; solve_model!(model);
</code></pre><pre><code class="language-julia-repl hljs"># using analytical gradient and degrees minor initial guess
julia&gt; solve_model!(model, method=:BFGS, analytical_gradient=true, initial=:degrees_minor)
(DBCM{Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Float64} (16 vertices, 15 unique degree pairs, 0.94 compression ratio), retcode: Success
u: [3.118482950362848, 2.2567400402511617, 2.2467332710940333, 0.8596258292464105, 0.4957550197436504, 0.3427782029923598, 0.126564995232929, -0.3127732185244699, -0.3967757456352901, -0.43450987676209596  …  -0.5626916621021604, 1.223396713832784, 0.10977479732876981, -1.0367565290851806, -2.0427364999923148, -0.650376357149203, -1.5165614611776657, 0.7532475835319463, 0.39856890694767605, -0.6704522097652438]
Final objective value:     120.15942408828177
)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/b608cc39a925907591eec3f681d82a56edb9cd4d/src/Models/DBCM.jl#L751-L784">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.initial_guess-Tuple{DBCM}" href="#MaxEntropyGraphs.initial_guess-Tuple{DBCM}"><code>MaxEntropyGraphs.initial_guess</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_guess(m::DBCM, method::Symbol=:degrees)</code></pre><p>Compute an initial guess for the maximum likelihood parameters of the DBCM model <code>m</code> using the method <code>method</code>.</p><p>The methods available are: </p><ul><li><code>:degrees</code> (default): the initial guess is computed using the degrees of the graph, i.e. <span>$\theta = [-\log(d_{out}); -\log(d_{in})]$</span> </li><li><code>:degrees_minor</code>: the initial guess is computed using the degrees of the graph and the number of edges, i.e. <span>$\theta = [-\log(d_{out}/(\sqrt{E} + 1)); -\log(d_{in}//(\sqrt{E} + 1) )]$</span></li><li><code>:random</code>: the initial guess is computed using random values between 0 and 1, i.e. <span>$\theta_{i} = -\log(r_{i})$</span> where <span>$r_{i} \sim U(0,1)$</span></li><li><code>:uniform</code>: the initial guess is uniformily set to 0.5, i.e. <span>$\theta_{i} = -\log(0.5)$</span></li><li><code>:chung_lu</code>: the initial guess is computed using the degrees of the graph and the number of edges, i.e. <span>$\theta = [-\log(d_{out}/(2E)); -\log(d_{in}/(2E))]$</span></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = DBCM(MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques()));

julia&gt; initial_guess(model, method=:random);

julia&gt; initial_guess(model, method=:uniform);

julia&gt; initial_guess(model, method=:degrees_minor);

julia&gt; initial_guess(model, method=:chung_lu);

julia&gt; initial_guess(model);
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/b608cc39a925907591eec3f681d82a56edb9cd4d/src/Models/DBCM.jl#L504-L531">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rand-Tuple{DBCM}" href="#Base.rand-Tuple{DBCM}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand(m::DBCM; precomputed=false)</code></pre><p>Generate a random graph from the DBCM model <code>m</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>precomputed::Bool</code>: if <code>true</code>, the precomputed expected adjacency matrix (<code>m.Ĝ</code>) is used to generate the random graph, otherwise the maximum likelihood parameters are used to generate the random graph on the fly. For larger networks, it is  recommended to not precompute the expected adjacency matrix to limit memory pressure.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># generate a DBCM model macaques network
julia&gt; G = MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques());

julia&gt; model = DBCM(G); 

julia&gt; solve_model!(model); # compute the maximum likelihood parameters

julia&gt; typeof(rand(model))
Graphs.SimpleGraphs.SimpleDiGraph{Int64}
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/b608cc39a925907591eec3f681d82a56edb9cd4d/src/Models/DBCM.jl#L665-L687">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rand-Tuple{DBCM, Int64}" href="#Base.rand-Tuple{DBCM, Int64}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand(m::DBCM, n::Int; precomputed=false)</code></pre><p>Generate <code>n</code> random graphs from the DBCM model <code>m</code>. If multithreading is available, the graphs are generated in parallel.</p><p><strong>Arguments</strong></p><ul><li><code>precomputed::Bool</code>: if <code>true</code>, the precomputed expected adjacency matrix (<code>m.Ĝ</code>) is used to generate the random graph, otherwise the maximum likelihood parameters are used to generate the random graph on the fly. For larger networks, it is  recommended to not precompute the expected adjacency matrix to limit memory pressure.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># generate a DBCM model macaques network
julia&gt; G = MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques());

julia&gt; model = DBCM(G); 

julia&gt; solve_model!(model); # compute the maximum likelihood parameters

julia&gt; typeof(rand(model, 10))
Vector{SimpleDiGraph{Int64}} (alias for Array{Graphs.SimpleGraphs.SimpleDiGraph{Int64}, 1})
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/b608cc39a925907591eec3f681d82a56edb9cd4d/src/Models/DBCM.jl#L715-L737">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.AIC-Tuple{DBCM}" href="#MaxEntropyGraphs.AIC-Tuple{DBCM}"><code>MaxEntropyGraphs.AIC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AIC(m::DBCM)</code></pre><p>Compute the Akaike Information Criterion (AIC) for the DBCM model <code>m</code>. The parameters of the models most be computed beforehand.  If the number of empirical observations becomes too small with respect to the number of parameters, you will get a warning. In  that case, the corrected AIC (AICc) should be used instead.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = DBCM(MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques()));

julia&gt; solve_model!(model);

julia&gt; AIC(model);
┌ Warning: The number of observations is small with respect to the number of parameters (n/k &lt; 40). Consider using the corrected AIC (AICc) instead.
[...]
</code></pre><p>See also <a href="../API_BiCM/#MaxEntropyGraphs.AICc-Tuple{BiCM}"><code>AICc</code></a>, <a href="#MaxEntropyGraphs.L_DBCM_reduced"><code>L_DBCM_reduced</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/b608cc39a925907591eec3f681d82a56edb9cd4d/src/Models/DBCM.jl#L1138-L1158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.AICc-Tuple{DBCM}" href="#MaxEntropyGraphs.AICc-Tuple{DBCM}"><code>MaxEntropyGraphs.AICc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AICc(m::DBCM)</code></pre><p>Compute the corrected Akaike Information Criterion (AICc) for the DBCM model <code>m</code>. The parameters of the models most be computed beforehand. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = DBCM(MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques()));

julia&gt; solve_model!(model);

julia&gt; AICc(model)
314.5217467272881
</code></pre><p>See also <a href="../API_BiCM/#MaxEntropyGraphs.AIC-Tuple{BiCM}"><code>AIC</code></a>, <a href="#MaxEntropyGraphs.L_DBCM_reduced"><code>L_DBCM_reduced</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/b608cc39a925907591eec3f681d82a56edb9cd4d/src/Models/DBCM.jl#L1176-L1194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.BIC-Tuple{DBCM}" href="#MaxEntropyGraphs.BIC-Tuple{DBCM}"><code>MaxEntropyGraphs.BIC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BIC(m::DBCM)</code></pre><p>Compute the Bayesian Information Criterion (BIC) for the DBCM model <code>m</code>. The parameters of the models most be computed beforehand.  BIC is believed to be more restrictive than AIC, as the former favors models with a lower number of parameters than those favored by the latter.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = DBCM(MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques()));

julia&gt; solve_model!(model);

julia&gt; BIC(model)
415.69929372350714
</code></pre><p>See also <a href="../API_BiCM/#MaxEntropyGraphs.AIC-Tuple{BiCM}"><code>AIC</code></a>, <a href="#MaxEntropyGraphs.L_DBCM_reduced"><code>L_DBCM_reduced</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/b608cc39a925907591eec3f681d82a56edb9cd4d/src/Models/DBCM.jl#L1207-L1225">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.length-Tuple{DBCM}" href="#Base.length-Tuple{DBCM}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the reduced number of nodes in the UBCM network</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/b608cc39a925907591eec3f681d82a56edb9cd4d/src/Models/DBCM.jl#L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.L_DBCM_reduced" href="#MaxEntropyGraphs.L_DBCM_reduced"><code>MaxEntropyGraphs.L_DBCM_reduced</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">L_DBCM_reduced(θ::Vector, k_out::Vector, k_in::Vector, F::Vector, nz_out::Vector, nz_in::Vector, n::Int=length(k_out))</code></pre><p>Compute the log-likelihood of the reduced DBCM model using the exponential formulation in order to maintain convexity.</p><p><strong>Arguments</strong></p><pre><code class="nohighlight hljs">- `θ`: the maximum likelihood parameters of the model ([α; β])
- `k_out`: the reduced outdegree sequence
- `k_in`: the reduced indegree sequence
- `F`: the frequency of each pair in the degree sequence
- `nz_out`: the indices of non-zero elements in the reduced outdegree sequence
- `nz_in`: the indices of non-zero elements in the reduced indegree sequence
- `n`: the number of nodes in the reduced model</code></pre><p>The function returns the log-likelihood of the reduced model. For the optimisation, this function will be used to generate an anonymous function associated with a specific model.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># Generic use:
julia&gt; k_out  = [1, 1, 1, 2, 2, 2, 3, 3, 4, 4, 4, 5, 5];

julia&gt; k_in   = [2, 3, 4, 1, 3, 5, 2, 4, 1, 2, 4, 0, 4];

julia&gt; F      = [2, 2, 1, 1, 1, 2, 3, 1, 1, 2, 2, 1, 1];

julia&gt; θ      = collect(range(0.1, step=0.1, length=length(k_out)));

julia&gt; nz_out = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];

julia&gt; nz_in  = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13];

julia&gt; n      = length(k_out);

julia&gt; L_DBCM_reduced(θ, k_out, k_in, F, nz_out, nz_in, n);
</code></pre><pre><code class="language-julia-repl hljs"># Use with DBCM model:
julia&gt; G = MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques());

julia&gt; model = DBCM(G);

julia&gt; model_fun = θ -&gt; L_DBCM_reduced(θ, model.dᵣ_out, model.dᵣ_in, model.f, model.dᵣ_out_nz, model.dᵣ_in_nz, model.status[:d_unique]);

julia&gt; model_fun(ones(size(model.θᵣ)))
-252.4627226503138</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/b608cc39a925907591eec3f681d82a56edb9cd4d/src/Models/DBCM.jl#L156-L204">source</a></section><section><div><pre><code class="language-julia hljs">L_DBCM_reduced(m::DBCM)</code></pre><p>Return the log-likelihood of the DBCM model <code>m</code> based on the computed maximum likelihood parameters.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># Use with DBCM model:
julia&gt; G = MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques());

julia&gt; model = DBCM(G);

julia&gt; solve_model!(model);

julia&gt; L_DBCM_reduced(model);
</code></pre><p>See also <a href="#MaxEntropyGraphs.L_DBCM_reduced"><code>L_DBCM_reduced(::Vector, ::Vector, ::Vector, ::Vector, ::Vector, ::Vector)</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/b608cc39a925907591eec3f681d82a56edb9cd4d/src/Models/DBCM.jl#L228-L247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.∇L_DBCM_reduced!" href="#MaxEntropyGraphs.∇L_DBCM_reduced!"><code>MaxEntropyGraphs.∇L_DBCM_reduced!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">∇L_DBCM_reduced!(∇L::AbstractVector, θ::AbstractVector, k_out::AbstractVector, k_in::AbstractVector, F::AbstractVector, nz_out::Vector, nz_in::Vector, x::AbstractVector, y::AbstractVector,n::Int)</code></pre><p>Compute the gradient of the log-likelihood of the reduced DBCM model using the exponential formulation in order to maintain convexity.</p><p>For the optimisation, this function will be used togenerate an anonymous function associated with a specific model. The function  will update pre-allocated vectors (<code>∇L</code>,<code>x</code> and <code>y</code>) for speed. The gradient is non-allocating.</p><p><strong>Arguments</strong></p><ul><li><code>∇L</code>: the gradient of the log-likelihood of the reduced model</li><li><code>θ</code>: the maximum likelihood parameters of the model ([α; β])</li><li><code>k_out</code>: the reduced outdegree sequence</li><li><code>k_in</code>: the reduced indegree sequence</li><li><code>F</code>: the frequency of each pair in the degree sequence</li><li><code>nz_out</code>: the indices of non-zero elements in the reduced outdegree sequence</li><li><code>nz_in</code>: the indices of non-zero elements in the reduced indegree sequence</li><li><code>x</code>: the exponentiated maximum likelihood parameters of the model ( xᵢ = exp(-αᵢ) )</li><li><code>y</code>: the exponentiated maximum likelihood parameters of the model ( yᵢ = exp(-βᵢ) )</li><li><code>n</code>: the number of nodes in the reduced model</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># Explicit use with DBCM model:
julia&gt; G = MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques());

julia&gt; model = DBCM(G);

julia&gt; ∇L = zeros(Real, length(model.θᵣ));

julia&gt; x  = zeros(Real, length(model.xᵣ));

julia&gt; y  = zeros(Real, length(model.yᵣ));

julia&gt; ∇model_fun! = θ -&gt; ∇L_DBCM_reduced!(∇L, θ, model.dᵣ_out, model.dᵣ_in, model.f, model.dᵣ_out_nz, model.dᵣ_in_nz, x, y, model.status[:d_unique]);

julia&gt; ∇model_fun!(model.θᵣ);
</code></pre><pre><code class="language-julia-repl hljs"># Use within optimisation.jl framework:
julia&gt; fun = (θ,p) -&gt; -L_DBCM_reduced(θ, model.dᵣ_out, model.dᵣ_in, model.f, model.dᵣ_out_nz, model.dᵣ_in_nz, model.status[:d_unique]);

julia&gt; x  = zeros(Real, length(model.xᵣ)); # initialise  buffer

julia&gt; y  = zeros(Real, length(model.yᵣ));#  initialise  buffer

julia&gt; ∇fun! = (∇L, θ, p) -&gt; ∇L_DBCM_reduced!(∇L, θ, model.dᵣ_out, model.dᵣ_in, model.f, model.dᵣ_out_nz, model.dᵣ_in_nz, x, y, model.status[:d_unique]);

julia&gt; θ₀ = initial_guess(model); # initial condition

julia&gt; foo = MaxEntropyGraphs.Optimization.OptimizationFunction(fun, grad=∇fun!); # define target function 

julia&gt; prob  = MaxEntropyGraphs.Optimization.OptimizationProblem(foo, θ₀); # define the optimisation problem

julia&gt; method = MaxEntropyGraphs.OptimizationOptimJL.LBFGS(); # set the optimisation method

julia&gt; MaxEntropyGraphs.Optimization.solve(prob, method); # solve it
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/b608cc39a925907591eec3f681d82a56edb9cd4d/src/Models/DBCM.jl#L257-L316">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.∇L_DBCM_reduced_minus!" href="#MaxEntropyGraphs.∇L_DBCM_reduced_minus!"><code>MaxEntropyGraphs.∇L_DBCM_reduced_minus!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">∇L_DBCM_reduced_minus!(args...)</code></pre><p>Compute minus the gradient of the log-likelihood of the reduced DBCM model using the exponential formulation in order to maintain convexity. Used for optimisation in a non-allocating manner.</p><p>See also <a href="#MaxEntropyGraphs.∇L_DBCM_reduced!"><code>∇L_DBCM_reduced!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/b608cc39a925907591eec3f681d82a56edb9cd4d/src/Models/DBCM.jl#L364-L370">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.DBCM_reduced_iter!" href="#MaxEntropyGraphs.DBCM_reduced_iter!"><code>MaxEntropyGraphs.DBCM_reduced_iter!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">DBCM_reduced_iter!(θ::AbstractVector, k_out::AbstractVector, k_in::AbstractVector, F::AbstractVector, nz_out::Vector, nz_in::Vector,x::AbstractVector, y::AbstractVector, G::AbstractVector, H::AbstractVector, n::Int)</code></pre><p>Compute the next fixed-point iteration for the DBCM model using the exponential formulation in order to maintain convexity. The function is non-allocating and will update pre-allocated vectors (<code>θ</code>, <code>x</code>, <code>y</code> and <code>G</code>) for speed.</p><p><strong>Arguments</strong></p><ul><li><code>θ</code>: the maximum likelihood parameters of the model ([α; β])</li><li><code>k_out</code>: the reduced outdegree sequence</li><li><code>k_in</code>: the reduced indegree sequence</li><li><code>F</code>: the frequency of each pair in the degree sequence</li><li><code>nz_out</code>: the indices of non-zero elements in the reduced outdegree sequence</li><li><code>nz_in</code>: the indices of non-zero elements in the reduced indegree sequence</li><li><code>x</code>: the exponentiated maximum likelihood parameters of the model ( xᵢ = exp(-αᵢ) )</li><li><code>y</code>: the exponentiated maximum likelihood parameters of the model ( yᵢ = exp(-βᵢ) )</li><li><code>G</code>: buffer for computations</li><li><code>n</code>: the number of nodes in the reduced model</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># Use with DBCM model:
julia&gt; G = MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques());

julia&gt; model = DBCM(G);

julia&gt; G = zeros(eltype(model.θᵣ), length(model.θᵣ));

julia&gt; H = zeros(eltype(model.θᵣ), length(model.yᵣ));

julia&gt; x = zeros(eltype(model.θᵣ), length(model.xᵣ));

julia&gt; y = zeros(eltype(model.θᵣ), length(model.yᵣ));

julia&gt; DBCM_FP! = θ -&gt; DBCM_reduced_iter!(θ, model.dᵣ_out, model.dᵣ_in, model.f, model.dᵣ_out_nz, model.dᵣ_in_nz, x, y, G, model.status[:d_unique]);

julia&gt; DBCM_FP!(model.θᵣ);
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/b608cc39a925907591eec3f681d82a56edb9cd4d/src/Models/DBCM.jl#L418-L457">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.set_xᵣ!-Tuple{DBCM}" href="#MaxEntropyGraphs.set_xᵣ!-Tuple{DBCM}"><code>MaxEntropyGraphs.set_xᵣ!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_xᵣ!(m::DBCM)</code></pre><p>Set the value of xᵣ to exp(-αᵣ) for the DBCM model <code>m</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/b608cc39a925907591eec3f681d82a56edb9cd4d/src/Models/DBCM.jl#L552-L556">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.set_yᵣ!-Tuple{DBCM}" href="#MaxEntropyGraphs.set_yᵣ!-Tuple{DBCM}"><code>MaxEntropyGraphs.set_yᵣ!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_yᵣ!(m::DBCM)</code></pre><p>Set the value of yᵣ to exp(-βᵣ) for the DBCM model <code>m</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/b608cc39a925907591eec3f681d82a56edb9cd4d/src/Models/DBCM.jl#L566-L570">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.Ĝ-Tuple{DBCM}" href="#MaxEntropyGraphs.Ĝ-Tuple{DBCM}"><code>MaxEntropyGraphs.Ĝ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Ĝ(m::DBCM)</code></pre><p>Compute the expected adjacency matrix for the DBCM model <code>m</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/b608cc39a925907591eec3f681d82a56edb9cd4d/src/Models/DBCM.jl#L581-L585">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.set_Ĝ!-Tuple{DBCM}" href="#MaxEntropyGraphs.set_Ĝ!-Tuple{DBCM}"><code>MaxEntropyGraphs.set_Ĝ!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_Ĝ!(m::DBCM)</code></pre><p>Set the expected adjacency matrix for the DBCM model <code>m</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/b608cc39a925907591eec3f681d82a56edb9cd4d/src/Models/DBCM.jl#L611-L615">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.σˣ-Tuple{DBCM}" href="#MaxEntropyGraphs.σˣ-Tuple{DBCM}"><code>MaxEntropyGraphs.σˣ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">σˣ(m::DBCM{T,N}) where {T,N}</code></pre><p>Compute the standard deviation for the elements of the adjacency matrix for the DBCM model <code>m</code>.</p><p><strong>Note:</strong> read as &quot;sigma star&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/b608cc39a925907591eec3f681d82a56edb9cd4d/src/Models/DBCM.jl#L623-L629">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.set_σ!-Tuple{DBCM}" href="#MaxEntropyGraphs.set_σ!-Tuple{DBCM}"><code>MaxEntropyGraphs.set_σ!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_σ!(m::DBCM)</code></pre><p>Set the standard deviation for the elements of the adjacency matrix for the DBCM model <code>m</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/b608cc39a925907591eec3f681d82a56edb9cd4d/src/Models/DBCM.jl#L653-L657">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.precision-Tuple{DBCM}" href="#Base.precision-Tuple{DBCM}"><code>Base.precision</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">precision(m::DBCM)</code></pre><p>Determine the compute precision of the DBCM model <code>m</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = DBCM(MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques()));

julia&gt; MaxEntropyGraphs.precision(model)
Float64</code></pre><pre><code class="language-julia-repl hljs">julia&gt; model = DBCM(MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques()), precision=Float32);

julia&gt; MaxEntropyGraphs.precision(model)
Float32</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/b608cc39a925907591eec3f681d82a56edb9cd4d/src/Models/DBCM.jl#L859-L878">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.A-Tuple{DBCM, Int64, Int64}" href="#MaxEntropyGraphs.A-Tuple{DBCM, Int64, Int64}"><code>MaxEntropyGraphs.A</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">A(m::DBCM,i::Int,j::Int)</code></pre><p>Return the expected value of the adjacency matrix for the DBCM model <code>m</code> at the node pair <code>(i,j)</code>.</p><p>❗ For perfomance reasons, the function does not check:</p><ul><li>if the node pair is valid.</li><li>if the parameters of the model have been computed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/b608cc39a925907591eec3f681d82a56edb9cd4d/src/Models/DBCM.jl#L891-L899">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.f_DBCM-Tuple{DBCM}" href="#MaxEntropyGraphs.f_DBCM-Tuple{DBCM}"><code>MaxEntropyGraphs.f_DBCM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">f_DBCM(x::T)</code></pre><p>Helper function for the DBCM model to compute the expected value of the adjacency matrix. The function computes the expression <code>x / (1 + x)</code>. As an argument you need to pass the product of the maximum likelihood parameters <code>xᵣ[i] * yᵣ[j]</code> from a DBCM model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/b608cc39a925907591eec3f681d82a56edb9cd4d/src/Models/DBCM.jl#L882-L887">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.σₓ-Tuple{DBCM, Function}" href="#MaxEntropyGraphs.σₓ-Tuple{DBCM, Function}"><code>MaxEntropyGraphs.σₓ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">σₓ(m::DBCM, X::function)</code></pre><p>Compute the standard deviation of metric <code>X</code> for the DBCM model <code>m</code>. </p><p>This requires that both the expected values (m.Ĝ) and standard deviations (m.σ) are computed for <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/b608cc39a925907591eec3f681d82a56edb9cd4d/src/Models/DBCM.jl#L1240-L1246">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../API_UBCM/">« UBCM</a><a class="docs-footer-nextpage" href="../API_BiCM/">BiCM »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Wednesday 10 April 2024 08:46">Wednesday 10 April 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
