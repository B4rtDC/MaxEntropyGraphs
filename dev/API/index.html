<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · MaxEntropyGraphs.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.jpeg" alt="MaxEntropyGraphs.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">MaxEntropyGraphs.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Models</span><ul><li><a class="tocitem" href="../models/">Overview</a></li><li><a class="tocitem" href="../models/UBCM/">UBCM</a></li><li><a class="tocitem" href="../models/DBCM/">DBCM</a></li><li><a class="tocitem" href="../models/BiCM/">BiCM</a></li></ul></li><li><span class="tocitem">Metrics</span><ul><li><a class="tocitem" href="../metrics/">Overview</a></li><li><a class="tocitem" href="../exact/">Analytical</a></li><li><a class="tocitem" href="../simulated/">Simulation</a></li></ul></li><li><a class="tocitem" href="../GPU/">GPU acceleration</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Global"><span>Global</span></a></li><li><a class="tocitem" href="#Utility-fuctions"><span>Utility fuctions</span></a></li><li><a class="tocitem" href="#Small-graph-constructors"><span>Small graph constructors</span></a></li><li><a class="tocitem" href="#Graph-metrics"><span>Graph metrics</span></a></li><li><a class="tocitem" href="#UBCM"><span>UBCM</span></a></li><li><a class="tocitem" href="#DBCM"><span>DBCM</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/main/docs/src/API.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#MaxEntropyGraphs"><code>MaxEntropyGraphs</code></a></li><li><a href="#MaxEntropyGraphs.AbstractMaxEntropyModel"><code>MaxEntropyGraphs.AbstractMaxEntropyModel</code></a></li><li><a href="#MaxEntropyGraphs.ConvergenceError"><code>MaxEntropyGraphs.ConvergenceError</code></a></li><li><a href="#MaxEntropyGraphs.DBCM"><code>MaxEntropyGraphs.DBCM</code></a></li><li><a href="#MaxEntropyGraphs.DBCM-Tuple{T} where T"><code>MaxEntropyGraphs.DBCM</code></a></li><li><a href="#MaxEntropyGraphs.UBCM-Tuple{T} where T"><code>MaxEntropyGraphs.UBCM</code></a></li><li><a href="#MaxEntropyGraphs.UBCM"><code>MaxEntropyGraphs.UBCM</code></a></li><li><a href="#Base.length-Tuple{DBCM}"><code>Base.length</code></a></li><li><a href="#Base.length-Tuple{UBCM}"><code>Base.length</code></a></li><li><a href="#Base.precision-Tuple{DBCM}"><code>Base.precision</code></a></li><li><a href="#Base.precision-Tuple{UBCM}"><code>Base.precision</code></a></li><li><a href="#Base.rand-Tuple{UBCM}"><code>Base.rand</code></a></li><li><a href="#Base.rand-Tuple{DBCM, Int64}"><code>Base.rand</code></a></li><li><a href="#Base.rand-Tuple{UBCM, Int64}"><code>Base.rand</code></a></li><li><a href="#Base.rand-Tuple{DBCM}"><code>Base.rand</code></a></li><li><a href="#MaxEntropyGraphs.A-Tuple{UBCM, Int64, Int64}"><code>MaxEntropyGraphs.A</code></a></li><li><a href="#MaxEntropyGraphs.A-Tuple{DBCM, Int64, Int64}"><code>MaxEntropyGraphs.A</code></a></li><li><a href="#MaxEntropyGraphs.AIC-Tuple{DBCM}"><code>MaxEntropyGraphs.AIC</code></a></li><li><a href="#MaxEntropyGraphs.AIC-Tuple{UBCM}"><code>MaxEntropyGraphs.AIC</code></a></li><li><a href="#MaxEntropyGraphs.AICc-Tuple{UBCM}"><code>MaxEntropyGraphs.AICc</code></a></li><li><a href="#MaxEntropyGraphs.AICc-Tuple{DBCM}"><code>MaxEntropyGraphs.AICc</code></a></li><li><a href="#MaxEntropyGraphs.ANND"><code>MaxEntropyGraphs.ANND</code></a></li><li><a href="#MaxEntropyGraphs.ANND_in"><code>MaxEntropyGraphs.ANND_in</code></a></li><li><a href="#MaxEntropyGraphs.ANND_out"><code>MaxEntropyGraphs.ANND_out</code></a></li><li><a href="#MaxEntropyGraphs.BIC-Tuple{UBCM}"><code>MaxEntropyGraphs.BIC</code></a></li><li><a href="#MaxEntropyGraphs.BIC-Tuple{DBCM}"><code>MaxEntropyGraphs.BIC</code></a></li><li><a href="#MaxEntropyGraphs.DBCM_reduced_iter!"><code>MaxEntropyGraphs.DBCM_reduced_iter!</code></a></li><li><a href="#MaxEntropyGraphs.L_DBCM_reduced"><code>MaxEntropyGraphs.L_DBCM_reduced</code></a></li><li><a href="#MaxEntropyGraphs.L_UBCM_reduced"><code>MaxEntropyGraphs.L_UBCM_reduced</code></a></li><li><a href="#MaxEntropyGraphs.M1"><code>MaxEntropyGraphs.M1</code></a></li><li><a href="#MaxEntropyGraphs.M10"><code>MaxEntropyGraphs.M10</code></a></li><li><a href="#MaxEntropyGraphs.M11"><code>MaxEntropyGraphs.M11</code></a></li><li><a href="#MaxEntropyGraphs.M12"><code>MaxEntropyGraphs.M12</code></a></li><li><a href="#MaxEntropyGraphs.M13"><code>MaxEntropyGraphs.M13</code></a></li><li><a href="#MaxEntropyGraphs.M2"><code>MaxEntropyGraphs.M2</code></a></li><li><a href="#MaxEntropyGraphs.M3"><code>MaxEntropyGraphs.M3</code></a></li><li><a href="#MaxEntropyGraphs.M4"><code>MaxEntropyGraphs.M4</code></a></li><li><a href="#MaxEntropyGraphs.M5"><code>MaxEntropyGraphs.M5</code></a></li><li><a href="#MaxEntropyGraphs.M6"><code>MaxEntropyGraphs.M6</code></a></li><li><a href="#MaxEntropyGraphs.M7"><code>MaxEntropyGraphs.M7</code></a></li><li><a href="#MaxEntropyGraphs.M8"><code>MaxEntropyGraphs.M8</code></a></li><li><a href="#MaxEntropyGraphs.M9"><code>MaxEntropyGraphs.M9</code></a></li><li><a href="#MaxEntropyGraphs.UBCM_reduced_iter!"><code>MaxEntropyGraphs.UBCM_reduced_iter!</code></a></li><li><a href="#MaxEntropyGraphs.a̲"><code>MaxEntropyGraphs.a̲</code></a></li><li><a href="#MaxEntropyGraphs.a⭠"><code>MaxEntropyGraphs.a⭠</code></a></li><li><a href="#MaxEntropyGraphs.a⭢"><code>MaxEntropyGraphs.a⭢</code></a></li><li><a href="#MaxEntropyGraphs.a⭤"><code>MaxEntropyGraphs.a⭤</code></a></li><li><a href="#MaxEntropyGraphs.chesapeakebay"><code>MaxEntropyGraphs.chesapeakebay</code></a></li><li><a href="#MaxEntropyGraphs.degree"><code>MaxEntropyGraphs.degree</code></a></li><li><a href="#MaxEntropyGraphs.everglades"><code>MaxEntropyGraphs.everglades</code></a></li><li><a href="#MaxEntropyGraphs.f_DBCM-Tuple{DBCM}"><code>MaxEntropyGraphs.f_DBCM</code></a></li><li><a href="#MaxEntropyGraphs.f_UBCM-Tuple{UBCM}"><code>MaxEntropyGraphs.f_UBCM</code></a></li><li><a href="#MaxEntropyGraphs.florida"><code>MaxEntropyGraphs.florida</code></a></li><li><a href="#MaxEntropyGraphs.indegree"><code>MaxEntropyGraphs.indegree</code></a></li><li><a href="#MaxEntropyGraphs.initial_guess-Tuple{UBCM}"><code>MaxEntropyGraphs.initial_guess</code></a></li><li><a href="#MaxEntropyGraphs.initial_guess-Tuple{DBCM}"><code>MaxEntropyGraphs.initial_guess</code></a></li><li><a href="#MaxEntropyGraphs.instrength"><code>MaxEntropyGraphs.instrength</code></a></li><li><a href="#MaxEntropyGraphs.littlerock"><code>MaxEntropyGraphs.littlerock</code></a></li><li><a href="#MaxEntropyGraphs.log_nan"><code>MaxEntropyGraphs.log_nan</code></a></li><li><a href="#MaxEntropyGraphs.maspalomas"><code>MaxEntropyGraphs.maspalomas</code></a></li><li><a href="#MaxEntropyGraphs.np_unique_clone"><code>MaxEntropyGraphs.np_unique_clone</code></a></li><li><a href="#MaxEntropyGraphs.outdegree"><code>MaxEntropyGraphs.outdegree</code></a></li><li><a href="#MaxEntropyGraphs.outstrength"><code>MaxEntropyGraphs.outstrength</code></a></li><li><a href="#MaxEntropyGraphs.parse_konect"><code>MaxEntropyGraphs.parse_konect</code></a></li><li><a href="#MaxEntropyGraphs.readpajek"><code>MaxEntropyGraphs.readpajek</code></a></li><li><a href="#MaxEntropyGraphs.rhesus_macaques"><code>MaxEntropyGraphs.rhesus_macaques</code></a></li><li><a href="#MaxEntropyGraphs.set_xᵣ!-Tuple{UBCM}"><code>MaxEntropyGraphs.set_xᵣ!</code></a></li><li><a href="#MaxEntropyGraphs.set_xᵣ!-Tuple{DBCM}"><code>MaxEntropyGraphs.set_xᵣ!</code></a></li><li><a href="#MaxEntropyGraphs.set_yᵣ!-Tuple{DBCM}"><code>MaxEntropyGraphs.set_yᵣ!</code></a></li><li><a href="#MaxEntropyGraphs.set_Ĝ!-Tuple{DBCM}"><code>MaxEntropyGraphs.set_Ĝ!</code></a></li><li><a href="#MaxEntropyGraphs.set_Ĝ!-Tuple{UBCM}"><code>MaxEntropyGraphs.set_Ĝ!</code></a></li><li><a href="#MaxEntropyGraphs.set_σ!-Tuple{DBCM}"><code>MaxEntropyGraphs.set_σ!</code></a></li><li><a href="#MaxEntropyGraphs.set_σ!-Tuple{UBCM}"><code>MaxEntropyGraphs.set_σ!</code></a></li><li><a href="#MaxEntropyGraphs.solve_model!-Tuple{UBCM}"><code>MaxEntropyGraphs.solve_model!</code></a></li><li><a href="#MaxEntropyGraphs.solve_model!-Tuple{DBCM}"><code>MaxEntropyGraphs.solve_model!</code></a></li><li><a href="#MaxEntropyGraphs.squares"><code>MaxEntropyGraphs.squares</code></a></li><li><a href="#MaxEntropyGraphs.stmarks"><code>MaxEntropyGraphs.stmarks</code></a></li><li><a href="#MaxEntropyGraphs.strength"><code>MaxEntropyGraphs.strength</code></a></li><li><a href="#MaxEntropyGraphs.taro_exchange"><code>MaxEntropyGraphs.taro_exchange</code></a></li><li><a href="#MaxEntropyGraphs.triangles"><code>MaxEntropyGraphs.triangles</code></a></li><li><a href="#MaxEntropyGraphs.wedges"><code>MaxEntropyGraphs.wedges</code></a></li><li><a href="#MaxEntropyGraphs.Ĝ-Tuple{UBCM}"><code>MaxEntropyGraphs.Ĝ</code></a></li><li><a href="#MaxEntropyGraphs.Ĝ-Tuple{DBCM}"><code>MaxEntropyGraphs.Ĝ</code></a></li><li><a href="#MaxEntropyGraphs.σˣ-Tuple{UBCM}"><code>MaxEntropyGraphs.σˣ</code></a></li><li><a href="#MaxEntropyGraphs.σˣ-Tuple{DBCM}"><code>MaxEntropyGraphs.σˣ</code></a></li><li><a href="#MaxEntropyGraphs.σₓ-Tuple{UBCM, Function}"><code>MaxEntropyGraphs.σₓ</code></a></li><li><a href="#MaxEntropyGraphs.σₓ-Tuple{DBCM, Function}"><code>MaxEntropyGraphs.σₓ</code></a></li><li><a href="#MaxEntropyGraphs.∇L_DBCM_reduced!"><code>MaxEntropyGraphs.∇L_DBCM_reduced!</code></a></li><li><a href="#MaxEntropyGraphs.∇L_DBCM_reduced_minus!"><code>MaxEntropyGraphs.∇L_DBCM_reduced_minus!</code></a></li><li><a href="#MaxEntropyGraphs.∇L_UBCM_reduced!"><code>MaxEntropyGraphs.∇L_UBCM_reduced!</code></a></li><li><a href="#MaxEntropyGraphs.∇L_UBCM_reduced_minus!"><code>MaxEntropyGraphs.∇L_UBCM_reduced_minus!</code></a></li></ul><h2 id="Global"><a class="docs-heading-anchor" href="#Global">Global</a><a id="Global-1"></a><a class="docs-heading-anchor-permalink" href="#Global" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs" href="#MaxEntropyGraphs"><code>MaxEntropyGraphs</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">MaxEntropyGraphs</code></pre><p>Julia module for working with maximum entropy graphs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/MaxEntropyGraphs.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.AbstractMaxEntropyModel" href="#MaxEntropyGraphs.AbstractMaxEntropyModel"><code>MaxEntropyGraphs.AbstractMaxEntropyModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractMaxEntropyModel</code></pre><p>An abstract type for a MaxEntropyModel. Each model has one or more structural constraints   that are fixed while the rest of the network is completely random. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/models.jl#L20-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.ConvergenceError" href="#MaxEntropyGraphs.ConvergenceError"><code>MaxEntropyGraphs.ConvergenceError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConvergenceError</code></pre><p>Exception thrown when the optimisation method does not converge. </p><p>When using and optimisation method from the <code>optimisation.jl</code> framework, the return code of the optimisation method is stored in the <code>retcode</code> field. When using the fixed point iteration method, the <code>retcode</code> field is set to <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/models.jl#L29-L36">source</a></section></article><h2 id="Utility-fuctions"><a class="docs-heading-anchor" href="#Utility-fuctions">Utility fuctions</a><a id="Utility-fuctions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-fuctions" title="Permalink"></a></h2><p>Some specific utility functions are made available:</p><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.log_nan" href="#MaxEntropyGraphs.log_nan"><code>MaxEntropyGraphs.log_nan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">log_nan(x::T)</code></pre><p>Same as <code>log(x)</code>, but returns <code>NaN</code> if <code>x &lt;= 0</code>. Inspired by <code>NaNMath.jl</code> and https://github.com/JuliaMath/NaNMath.jl/issues/63. This methods is prefered over the ones from <code>NaNMath.jl</code> version because it does not require a foreign call expression to be evaluated, hence autodiff methods can be used with this.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; MaxEntropyGraphs.log_nan(10.)
2.302585092994046

julia&gt; MaxEntropyGraphs.log_nan(-10.)
NaN</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L78-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.np_unique_clone" href="#MaxEntropyGraphs.np_unique_clone"><code>MaxEntropyGraphs.np_unique_clone</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">np_unique_clone(x::Vector; sorted::Bool=false)</code></pre><p>Julia replication of the numpy.unique(a, return<em>counts=True, return</em>index=True, return_inverse=True) function from Python.</p><p>Returns a tuple of:</p><ul><li>vector of unique values in x</li><li>vector of indices of the first occurence of each unique value in x. Follows the same order as the unique values.</li><li>vector of inverse indices of the original data in the unique values</li><li>vector of the counts of the unique values in x. Follows the same order as the unique values.</li></ul><p>If sorted is true, the unique values are sorted by size and the other vectors are sorted accordingly.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [1;2;2;4;1];

julia&gt; np_unique_clone(x)
([1, 2, 4], [1, 2, 4], [1, 2, 2, 3, 1], [2, 2, 1])

julia&gt; x = [10;9;9;8];

julia&gt; np_unique_clone(x, sorted=true)
([8, 9, 10], [4, 2, 1], [3, 2, 2, 1], [1, 2, 1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L8-L33">source</a></section></article><h2 id="Small-graph-constructors"><a class="docs-heading-anchor" href="#Small-graph-constructors">Small graph constructors</a><a id="Small-graph-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Small-graph-constructors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.taro_exchange" href="#MaxEntropyGraphs.taro_exchange"><code>MaxEntropyGraphs.taro_exchange</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">taro_exchange()</code></pre><p>A small directed network that contains gift-givings (taro) between households in a Papuan village. A node represents a household and an edge between two households indicates that there happened a gift-giving. The network is directed and contains 22 nodes and 78 edges.</p><p>See also: <a href="http://konect.cc/networks/moreno_taro/">KONECT</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/smallnetworks.jl#L106-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.rhesus_macaques" href="#MaxEntropyGraphs.rhesus_macaques"><code>MaxEntropyGraphs.rhesus_macaques</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rhesus_maqaques()</code></pre><p>A small weighted, directed network that contains observed grooming episodes between free ranging rhesus macaques (Macaca mulatta) in Cayo Santiago during a two month period in 1963. Cayo Santiago is an island off the coast of Puerto Rico, also known as Isla de los monos (Island of the monkeys). A node represents a monkey and a directed edge A → B denotes that the rhesus macaque A groomed rhesus macaque B. The integer edge weights indicate how often this behaviour was observed.</p><p>See also: <a href="http://konect.cc/networks/moreno_rhesus/">KONECT</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/smallnetworks.jl#L116-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.chesapeakebay" href="#MaxEntropyGraphs.chesapeakebay"><code>MaxEntropyGraphs.chesapeakebay</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">chesapeakebay()</code></pre><p>A small foodweb (directed network) of the Chesapeake Bay. </p><p>Original data available <a href="http://vlado.fmf.uni-lj.si/pub/networks/data/bio/foodweb/foodweb.htm">here</a></p><p>See also: <a href="#MaxEntropyGraphs.readpajek"><code>MaxEntropyGraphs.readpajek</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/smallnetworks.jl#L131-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.everglades" href="#MaxEntropyGraphs.everglades"><code>MaxEntropyGraphs.everglades</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">everglades()</code></pre><p>A small foodweb (directed network) of the Everglades. </p><p>Original data available <a href="http://vlado.fmf.uni-lj.si/pub/networks/data/bio/foodweb/foodweb.htm">here</a></p><p>See also: <a href="#MaxEntropyGraphs.readpajek"><code>MaxEntropyGraphs.readpajek</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/smallnetworks.jl#L142-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.florida" href="#MaxEntropyGraphs.florida"><code>MaxEntropyGraphs.florida</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">florida()</code></pre><p>A small foodweb (directed network) of the Florida Bay. </p><p>Original data available <a href="http://vlado.fmf.uni-lj.si/pub/networks/data/bio/foodweb/foodweb.htm">here</a></p><p>See also: <a href="#MaxEntropyGraphs.readpajek"><code>MaxEntropyGraphs.readpajek</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/smallnetworks.jl#L154-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.littlerock" href="#MaxEntropyGraphs.littlerock"><code>MaxEntropyGraphs.littlerock</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">littlerock()</code></pre><p>A small foodweb (directed network) of the Little Rock Lake. </p><p>Original data available <a href="http://konect.cc/networks/maayan-foodweb/">here</a></p><p>See also: <a href="#MaxEntropyGraphs.parse_konect"><code>MaxEntropyGraphs.parse_konect</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/smallnetworks.jl#L166-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.maspalomas" href="#MaxEntropyGraphs.maspalomas"><code>MaxEntropyGraphs.maspalomas</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">maspalomas()</code></pre><p>A small foodweb (directed network) from Charca de Maspalomas. </p><p>Original data available <a href="http://vlado.fmf.uni-lj.si/pub/networks/data/bio/foodweb/foodweb.htm">here</a></p><p>See also: <a href="#MaxEntropyGraphs.readpajek"><code>MaxEntropyGraphs.readpajek</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/smallnetworks.jl#L178-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.stmarks" href="#MaxEntropyGraphs.stmarks"><code>MaxEntropyGraphs.stmarks</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stmarks()</code></pre><p>A small foodweb (directed network) from the St. Marks River. </p><p>Original data available <a href="http://vlado.fmf.uni-lj.si/pub/networks/data/bio/foodweb/foodweb.htm">here</a></p><p>See also: <a href="#MaxEntropyGraphs.readpajek"><code>MaxEntropyGraphs.readpajek</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/smallnetworks.jl#L190-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.parse_konect" href="#MaxEntropyGraphs.parse_konect"><code>MaxEntropyGraphs.parse_konect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parse_konect(content::String)</code></pre><p>Helper function to parse network data from the <a href="http://konect.cc">KONECT Project</a> and return it to a graph object in the JuliaGraphs ecosystem.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># read the data from a file
G = open(io -&gt; parse_konect(read(io, String)), &quot;/path/to/KONECT/network/data&quot;)
# store the graph in Graphs.jl format
savegraph(&quot;path/to/my_KONECT_graph.lgz&quot;, G)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/smallnetworks.jl#L8-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.readpajek" href="#MaxEntropyGraphs.readpajek"><code>MaxEntropyGraphs.readpajek</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">readpajek(f::String; is_directed::Bool=true)</code></pre><p>helper function to load a network from the <a href="http://vlado.fmf.uni-lj.si/pub/networks/data/bio/foodweb/foodweb.htm">pajek dataset</a> and return it to a graph object in the JuliaGraphs ecosystem.</p><p>For this simple helper, weights are discarded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/smallnetworks.jl#L67-L73">source</a></section></article><h2 id="Graph-metrics"><a class="docs-heading-anchor" href="#Graph-metrics">Graph metrics</a><a id="Graph-metrics-1"></a><a class="docs-heading-anchor-permalink" href="#Graph-metrics" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.degree" href="#MaxEntropyGraphs.degree"><code>MaxEntropyGraphs.degree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">degree(m::UBCM, i::Int; method=:reduced)</code></pre><p>Return the expected degree vector for node <code>i</code> of the UBCM model <code>m</code>. Uses the reduced model parameters <code>xᵣ</code> for perfomance reasons.</p><p><strong>Arguments</strong></p><ul><li><code>m::UBCM</code>: the UBCM model</li><li><code>i::Int</code>: the node for which to compute the degree.</li><li><code>method::Symbol</code>: the method to use for computing the degree. Can be any of the following:<ul><li><code>:reduced</code> (default) uses the reduced model parameters <code>xᵣ</code> for perfomance reasons.</li><li><code>:full</code> uses all elements of the expected adjacency matrix.</li><li><code>:adjacency</code> uses the precomputed adjacency matrix <code>m.Ĝ</code> of the model.</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = UBCM(MaxEntropyGraphs.Graphs.SimpleGraphs.smallgraph(:karate));

julia&gt; solve_model!(model);

julia&gt; set_Ĝ!(model);

julia&gt; typeof([degree(model, 1), degree(model, 1, method=:full), degree(model, 1, method=:adjacency)])
Vector{Float64} (alias for Array{Float64, 1})
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/UBCM.jl#L775-L801">source</a></section><section><div><pre><code class="nohighlight hljs">degree(m::UBCM[, v]; method=:reduced)</code></pre><p>Return a vector corresponding to the expected degree of the UBCM model <code>m</code> each node. If v is specified, only return degrees for nodes in v.</p><p><strong>Arguments</strong></p><ul><li><code>m::UBCM</code>: the UBCM model</li><li><code>v::Vector{Int}</code>: the nodes for which to compute the degree. Default is all nodes.</li><li><code>method::Symbol</code>: the method to use for computing the degree. Can be any of the following:<ul><li><code>:reduced</code> (default) uses the reduced model parameters <code>xᵣ</code> for perfomance reasons.</li><li><code>:full</code> uses all elements of the expected adjacency matrix.</li><li><code>:adjacency</code> uses the precomputed adjacency matrix <code>m.Ĝ</code> of the model.</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = UBCM(MaxEntropyGraphs.Graphs.SimpleGraphs.smallgraph(:karate));

julia&gt; solve_model!(model);

julia&gt; set_Ĝ!(model);

julia&gt; typeof(degree(model, method=:adjacency)) 
Vector{Float64} (alias for Array{Float64, 1})
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/UBCM.jl#L835-L860">source</a></section><section><div><pre><code class="nohighlight hljs">degree(m::DBCM, i::Int; method=:reduced)</code></pre><p>In alignment with <code>Graphs.jl</code>, returns the sum of the expected out- and indegree for node <code>i</code> of the DBCM model <code>m</code>. Uses the reduced model parameters <code>xᵣ</code> for perfomance reasons.</p><p><strong>Arguments</strong></p><ul><li><code>m::DBCM</code>: the DBCM model</li><li><code>i::Int</code>: the node for which to compute the degree.</li><li><code>method::Symbol</code>: the method to use for computing the degree. Can be any of the following:<ul><li><code>:reduced</code> (default) uses the reduced model parameters <code>xᵣ</code> for perfomance reasons.</li><li><code>:full</code> uses all elements of the expected adjacency matrix.</li><li><code>:adjacency</code> uses the precomputed adjacency matrix <code>m.Ĝ</code> of the model.</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = DBCM(MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques()));

julia&gt; solve_model!(model);

julia&gt; set_Ĝ!(model);

julia&gt; typeof([degree(model, 1), degree(model, 1, method=:full), degree(model, 1, method=:adjacency)])
Vector{Float64} (alias for Array{Float64, 1})
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/DBCM.jl#L1082-L1108">source</a></section><section><div><pre><code class="nohighlight hljs">degree(m::DBCM[, v]; method=:reduced)</code></pre><p>In alignment with <code>Graphs.jl</code>, returns a vector corresponding to the sum of the expected out- and indegree of the DBCM model <code>m</code> each node. If v is specified, only return indegrees for nodes in v.</p><p><strong>Arguments</strong></p><ul><li><code>m::DBCM</code>: the DBCM model</li><li><code>v::Vector{Int}</code>: the nodes for which to compute the degree. Default is all nodes.</li><li><code>method::Symbol</code>: the method to use for computing the degree. Can be any of the following:<ul><li><code>:reduced</code> (default) uses the reduced model parameters <code>xᵣ</code> for perfomance reasons.</li><li><code>:full</code> uses all elements of the expected adjacency matrix.</li><li><code>:adjacency</code> uses the precomputed adjacency matrix <code>m.Ĝ</code> of the model.</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = DBCM(MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques()));

julia&gt; solve_model!(model);

julia&gt; set_Ĝ!(model);

julia&gt; typeof(degree(model, method=:adjacency)) 
Vector{Float64} (alias for Array{Float64, 1})
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/DBCM.jl#L1111-L1136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.outdegree" href="#MaxEntropyGraphs.outdegree"><code>MaxEntropyGraphs.outdegree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">outdegree(m::DBCM, i::Int; method=:reduced)</code></pre><p>Return the expected degree vector for node <code>i</code> of the DBCM model <code>m</code>. Uses the reduced model parameters <code>xᵣ</code> for perfomance reasons.</p><p><strong>Arguments</strong></p><ul><li><code>m::DBCM</code>: the DBCM model</li><li><code>i::Int</code>: the node for which to compute the degree.</li><li><code>method::Symbol</code>: the method to use for computing the degree. Can be any of the following:<ul><li><code>:reduced</code> (default) uses the reduced model parameters <code>xᵣ</code> for perfomance reasons.</li><li><code>:full</code> uses all elements of the expected adjacency matrix.</li><li><code>:adjacency</code> uses the precomputed adjacency matrix <code>m.Ĝ</code> of the model.</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = DBCM(MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques()));

julia&gt; solve_model!(model);

julia&gt; set_Ĝ!(model);

julia&gt; typeof([outdegree(model, 1), outdegree(model, 1, method=:full), outdegree(model, 1, method=:adjacency)])
Vector{Float64} (alias for Array{Float64, 1})
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/DBCM.jl#L906-L932">source</a></section><section><div><pre><code class="nohighlight hljs">outdegree(m::DBCM[, v]; method=:reduced)</code></pre><p>Return a vector corresponding to the expected outdegree of the DBCM model <code>m</code> each node. If v is specified, only return outdegrees for nodes in v.</p><p><strong>Arguments</strong></p><ul><li><code>m::DBCM</code>: the DBCM model</li><li><code>v::Vector{Int}</code>: the nodes for which to compute the outdegree. Default is all nodes.</li><li><code>method::Symbol</code>: the method to use for computing the outdegree. Can be any of the following:<ul><li><code>:reduced</code> (default) uses the reduced model parameters <code>xᵣ</code> for perfomance reasons.</li><li><code>:full</code> uses all elements of the expected adjacency matrix.</li><li><code>:adjacency</code> uses the precomputed adjacency matrix <code>m.Ĝ</code> of the model.</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = DBCM(MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques()));

julia&gt; solve_model!(model);

julia&gt; set_Ĝ!(model);

julia&gt; typeof(outdegree(model, method=:adjacency)) 
Vector{Float64} (alias for Array{Float64, 1})
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/DBCM.jl#L965-L990">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.indegree" href="#MaxEntropyGraphs.indegree"><code>MaxEntropyGraphs.indegree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">indegree(m::DBCM, i::Int; method=:reduced)</code></pre><p>Return the expected degree vector for node <code>i</code> of the DBCM model <code>m</code>. Uses the reduced model parameters <code>xᵣ</code> for perfomance reasons.</p><p><strong>Arguments</strong></p><ul><li><code>m::DBCM</code>: the DBCM model</li><li><code>i::Int</code>: the node for which to compute the degree.</li><li><code>method::Symbol</code>: the method to use for computing the degree. Can be any of the following:<ul><li><code>:reduced</code> (default) uses the reduced model parameters <code>xᵣ</code> for perfomance reasons.</li><li><code>:full</code> uses all elements of the expected adjacency matrix.</li><li><code>:adjacency</code> uses the precomputed adjacency matrix <code>m.Ĝ</code> of the model.</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = DBCM(MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques()));

julia&gt; solve_model!(model);

julia&gt; set_Ĝ!(model);

julia&gt; typeof([indegree(model, 1), indegree(model, 1, method=:full), indegree(model, 1, method=:adjacency)])
Vector{Float64} (alias for Array{Float64, 1})
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/DBCM.jl#L994-L1020">source</a></section><section><div><pre><code class="nohighlight hljs">indegree(m::DBCM[, v]; method=:reduced)</code></pre><p>Return a vector corresponding to the expected indegree of the DBCM model <code>m</code> each node. If v is specified, only return indegrees for nodes in v.</p><p><strong>Arguments</strong></p><ul><li><code>m::DBCM</code>: the DBCM model</li><li><code>v::Vector{Int}</code>: the nodes for which to compute the indegree. Default is all nodes.</li><li><code>method::Symbol</code>: the method to use for computing the indegree. Can be any of the following:<ul><li><code>:reduced</code> (default) uses the reduced model parameters <code>xᵣ</code> for perfomance reasons.</li><li><code>:full</code> uses all elements of the expected adjacency matrix.</li><li><code>:adjacency</code> uses the precomputed adjacency matrix <code>m.Ĝ</code> of the model.</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = DBCM(MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques()));

julia&gt; solve_model!(model);

julia&gt; set_Ĝ!(model);

julia&gt; typeof(indegree(model, method=:adjacency)) 
Vector{Float64} (alias for Array{Float64, 1})
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/DBCM.jl#L1054-L1079">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.strength" href="#MaxEntropyGraphs.strength"><code>MaxEntropyGraphs.strength</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">strength(G, T; dir)</code></pre><p>Construct the strength vector for the graph <code>G</code>, filled with element type <code>T</code> and considering edge direction <code>dir ∈ [:in, :out, :both]</code> (default is <code>:out</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L100-L104">source</a></section><section><div><pre><code class="nohighlight hljs">strength(G, i, T; dir)</code></pre><p>Construct the strength of node <code>i</code> for the graph <code>G</code>, filled with element type <code>T</code> and considering edge direction <code>dir ∈ [:in, :out, :both]</code> (default is <code>:out</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L139-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.outstrength" href="#MaxEntropyGraphs.outstrength"><code>MaxEntropyGraphs.outstrength</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">instrength(G, T; dir)</code></pre><p>Construct the outstrength vector for the graph <code>G</code>, filled with element type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L131-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.instrength" href="#MaxEntropyGraphs.instrength"><code>MaxEntropyGraphs.instrength</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">instrength(G, T; dir)</code></pre><p>Construct the instrength vector for the graph <code>G</code>, filled with element type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L124-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.ANND" href="#MaxEntropyGraphs.ANND"><code>MaxEntropyGraphs.ANND</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ANND(G::T, i::Int; check_directed::Bool=true) where {T&lt;:Graphs.AbstractGraph}</code></pre><p>Compute the average nearest neighbor degree (ANND) for node <code>i</code> in graph <code>G</code>. The ANND for a node <code>i</code> is defined as <span>$ANND_i(A^{*}) = \frac{\sum_{j=1}^{N} a_{ij}k_j }{k_i}$</span> where <span>$a_{ij}$</span> denotes the element of the adjacency matrix <span>$A$</span> at row <span>$i$</span> and column <span>$j$</span>, and <span>$k_i$</span> denotes the degree of node <span>$i$</span>.</p><p><strong>Notes:</strong> </p><ul><li>the ANND is only defined for nodes with nonzero degree. If <code>degree(G,i) = 0</code>, then <code>ANND(G,i) = 0</code>.</li><li>if <code>G</code> is a directed graph, by default an error is thrown because the <code>degree</code> function returns the incoming plus outgoing edges for node <code>i</code> in this case.   This can be turned off by setting <code>check_directed=false</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Graphs

julia&gt; G = smallgraph(:karate);

julia&gt; ANND(G,1)
4.3125
</code></pre><pre><code class="language-julia-repl hljs">julia&gt; add_vertex!(G);

julia&gt; ANND(G, nv(G))
0.0</code></pre><pre><code class="language-julia-repl hljs">julia&gt; Gd = SimpleDiGraph(G);

julia&gt; ANND(Gd,1)
ERROR: ArgumentError: The graph is directed. The degree function returns the incoming plus outgoing edges for node `i`. Consider using ANND_in or ANND_out instead.
[...]</code></pre><pre><code class="language-julia-repl hljs">julia&gt; ANND(Gd,1, check_directed=false)
4.3125</code></pre><p>See also: <a href="#MaxEntropyGraphs.ANND_in"><code>ANND_in</code></a>, <a href="#MaxEntropyGraphs.ANND_out"><code>ANND_out</code></a>, <a href="https://juliagraphs.org/Graphs.jl/stable/core_functions/core/#Graphs.degree"><code>Graphs.degree</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L163-L207">source</a></section><section><div><pre><code class="nohighlight hljs">ANND(G::T, vs=vertices(G); check_directed::Bool=true) where {T&lt;:Graphs.AbstractGraph}</code></pre><p>Return a vector correcponding to the average nearest neighbor degree (ANND) all nodes in the graph <code>G</code>.  If v is specified, only return the ANND for nodes in v. The ANND for a node <code>i</code> is defined as  <span>$ANND_i(A^{*}) = \frac{\sum_{j=1}^{N} a_{ij}k_j }{k_i}$</span> where <span>$a_{ij}$</span> denotes the element of the adjacency matrix <span>$A$</span> at row <span>$i$</span> and column <span>$j$</span>, and <span>$k_i$</span> denotes the degree of node <span>$i$</span>.</p><p><strong>Notes:</strong> </p><ul><li>the ANND is only defined for nodes with nonzero degree. If <code>degree(G,i) = 0</code>, then <code>ANND(G,i) = 0</code>.</li><li>if <code>G</code> is a directed graph, by default an error is thrown because the <code>degree</code> function returns the incoming plus outgoing edges for node <code>i</code> in this case.</li></ul><p>This can be turned off by setting <code>check_directed=false</code>. This check is only performed once the actual computing.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Graphs

julia&gt; G = smallgraph(:karate);

julia&gt; ANND(G,[10; 20; 30])
3-element Vector{Float64}:
 13.5
 14.0
  9.0
</code></pre><pre><code class="language-julia-repl hljs">julia&gt; Gd = SimpleDiGraph(G);

julia&gt; ANND(Gd,[10; 20; 30]);
ERROR: ArgumentError: The graph is directed. The degree function returns the incoming plus outgoing edges for node `i`. Consider using ANND_in or ANND_out instead.
[...]</code></pre><pre><code class="language-julia-repl hljs">julia&gt; ANND(Gd,[10; 20; 30], check_directed=false)
3-element Vector{Float64}:
 13.5
 14.0
  9.0
</code></pre><p>See also: <code>ANND_in</code>, <code>ANND_out</code>, <a href="https://juliagraphs.org/Graphs.jl/stable/core_functions/core/#Graphs.degree"><code>Graphs.degree</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L221-L267">source</a></section><section><div><pre><code class="nohighlight hljs">ANND(A::T, i::Int; check_dimensions::Bool=true, check_directed::Bool=true) where {T&lt;:AbstractMatrix}</code></pre><p>Compute the average nearest neighbor degree (ANND) for node <code>i</code> using adjacency matrix <code>A</code>. The ANND for a node <code>i</code> is defined as <span>$ANND_i(A^{*}) = \frac{\sum_{j=1}^{N} a_{ij}k_j }{k_i}$</span> where <span>$a_{ij}$</span> denotes the element of the adjacency matrix <span>$A$</span> at row <span>$i$</span> and column <span>$j$</span>, and <span>$k_i$</span> denotes the degree of node <span>$i$</span>.</p><p><strong>Notes:</strong> </p><ul><li>this function is intented for use with the expected adjacency matrix of a <code>::AbstractMaxEntropyModel</code> model. A separate method exists for <code>::AbstractGraph</code> objects.</li><li>if <code>A</code> is not symmetrical, you have a directed graph, and this will throw an error by default. This can be turned off by setting <code>check_directed=false</code>.</li><li>the adjacency matrix should be square, if not, this will throw an error by default. This can be turned off by setting <code>check_dimensions=false</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Graphs

julia&gt; G = smallgraph(:karate);

julia&gt; A = adjacency_matrix(G);

julia&gt; ANND(A, 1)
4.3125
</code></pre><pre><code class="language-julia-repl hljs">julia&gt; Gd = SimpleDiGraph(G);

julia&gt; add_vertex!(Gd); add_edge!(Gd, 1, nv(Gd));

julia&gt; Ad = adjacency_matrix(Gd);

julia&gt; ANND(Ad, 1)
ERROR: ArgumentError: The matrix is not symmetrical. Consider using ANND_in or ANND_out instead.
[...]</code></pre><pre><code class="language-julia-repl hljs">julia&gt; ANND(Ad, 1, check_directed=false)
4.375
</code></pre><pre><code class="language-julia-repl hljs">julia&gt; ANND(rand(2,3),1)
ERROR: DimensionMismatch: `A` must be a square matrix.
[...]</code></pre><p>See also: <code>ANND_in</code>, <code>ANND_out</code>, <a href="https://juliagraphs.org/Graphs.jl/stable/core_functions/core/#Graphs.degree"><code>Graphs.degree</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L280-L329">source</a></section><section><div><pre><code class="nohighlight hljs">ANND(A::T, vs=1:size(A,1); check_dimensions::Bool=true, check_directed::Bool=true) where {T&lt;:AbstractMatrix}</code></pre><p>Return a vector correcponding to the average nearest neighbor degree (ANND) all nodes in the graph with adjacency matrix <code>A</code>.  If v is specified, only return the ANND for nodes in v. The ANND for a node <code>i</code> is defined as  <span>$ANND_i(A^{*}) = \frac{\sum_{j=1}^{N} a_{ij}k_j }{k_i}$</span> where <span>$a_{ij}$</span> denotes the element of the adjacency matrix <span>$A$</span> at row <span>$i$</span> and column <span>$j$</span>, and <span>$k_i$</span> denotes the degree of node <span>$i$</span>.</p><p><strong>Notes:</strong> </p><ul><li>this function is intented for use with the expected adjacency matrix of a <code>::AbstractMaxEntropyModel</code> model. A separate method exists for <code>::AbstractGraph</code> objects.</li><li>if <code>A</code> is not symmetrical, you have a directed graph, and this will throw an error by default. This can be turned off by setting <code>check_directed=false</code>.</li><li>the adjacency matrix should be square, if not, this will throw an error by default. This can be turned off by setting <code>check_dimensions=false</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Graphs

julia&gt; G = smallgraph(:karate);

julia&gt; A = adjacency_matrix(G);

julia&gt; ANND(A);
</code></pre><pre><code class="language-julia-repl hljs">julia&gt; Gd = SimpleDiGraph(G);

julia&gt; add_vertex!(Gd); add_edge!(Gd, 1, nv(Gd));

julia&gt; Ad = adjacency_matrix(Gd);

julia&gt; ANND(Ad)
ERROR: ArgumentError: The matrix is not symmetrical. Consider using ANND_in or ANND_out instead.
[...]</code></pre><pre><code class="language-julia-repl hljs">julia&gt; ANND(Ad, check_directed=false)[1]
4.375
</code></pre><pre><code class="language-julia-repl hljs">julia&gt; ANND(rand(2,3))
ERROR: DimensionMismatch: `A` must be a square matrix.
[...]</code></pre><p>See also: <code>ANND_in</code>, <code>ANND_out</code>, <a href="https://juliagraphs.org/Graphs.jl/stable/core_functions/core/#Graphs.degree"><code>Graphs.degree</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L347-L396">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.ANND_out" href="#MaxEntropyGraphs.ANND_out"><code>MaxEntropyGraphs.ANND_out</code></a> — <span class="docstring-category">Function</span></header><section><div><p>ANND<em>out(A::T, vs=1:size(A,1); check</em>dimensions::Bool=true, check_directed::Bool=true) where {T&lt;:AbstractMatrix}</p><p>Return a vector corresponding to the average nearest neighbor outdegree (ANND) all nodes in the graph with adjacency matrix <code>A</code>.  If v is specified, only return the ANND_out for nodes in v. </p><p>See also: <a href="#MaxEntropyGraphs.ANND_in"><code>ANND_in</code></a>, <a href="#MaxEntropyGraphs.ANND"><code>ANND</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L423-L431">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.ANND_in" href="#MaxEntropyGraphs.ANND_in"><code>MaxEntropyGraphs.ANND_in</code></a> — <span class="docstring-category">Function</span></header><section><div><p>ANND<em>in(A::T, vs=1:size(A,1); check</em>dimensions::Bool=true, check_directed::Bool=true) where {T&lt;:AbstractMatrix}</p><p>Return a vector corresponding to the average nearest neighbor indegree (ANND) all nodes in the graph with adjacency matrix <code>A</code>.  If v is specified, only return the ANND_in for nodes in v. </p><p>See also: <a href="#MaxEntropyGraphs.ANND_out"><code>ANND_out</code></a>, <a href="#MaxEntropyGraphs.ANND"><code>ANND</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L468-L476">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.wedges" href="#MaxEntropyGraphs.wedges"><code>MaxEntropyGraphs.wedges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">wedges(G::Graphs.SimpleGraph)
wedges(A::T; check_dimensions::Bool=true, check_directed::Bool=true) where {T&lt;:AbstractMatrix}
wedges(m::UBCM)</code></pre><p>Compute the number of (expected) wedges for an undirected graph. Can be done directly from the graph, based on the adjacency matrix or a UBCM model.</p><p><strong>Arguments</strong></p><p>For the adjacency matrix <code>A</code>, the following arguments can be passed:</p><ul><li><code>check_dimensions</code>: if true, check that <code>A</code> is a square matrix, otherwise throw an error.</li><li><code>check_directed</code>: if true, check that <code>A</code> is symmetrical, otherwise throw an error.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; G = MaxEntropyGraphs.Graphs.smallgraph(:karate);

julia&gt; model = UBCM(G);

julia&gt; solve_model!(model);

julia&gt; set_Ĝ!(model);

julia&gt; (wedges(G), wedges(MaxEntropyGraphs.Graphs.adjacency_matrix(G)), wedges(model))
(528.0, 528.0, 528.0000011499742)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L506-L531">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.triangles" href="#MaxEntropyGraphs.triangles"><code>MaxEntropyGraphs.triangles</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">triangles(G::Graphs.SimpleGraph)
triangles(A::T; check_dimensions::Bool=true, check_directed::Bool=true) where {T&lt;:AbstractMatrix}
triangles(m::UBCM)</code></pre><p>Compute the number of (expected) triangles for an undirected graph. Can be done directly from the graph, based on the adjacency matrix or a UBCM model.</p><p><strong>Arguments</strong></p><p>For the adjacency matrix <code>A</code>, the following arguments can be passed:</p><ul><li><code>check_dimensions</code>: if true, check that <code>A</code> is a square matrix, otherwise throw an error.</li><li><code>check_directed</code>: if true, check that <code>A</code> is symmetrical, otherwise throw an error.</li></ul><p>These checks can be turned off for perfomance reasons.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; G = MaxEntropyGraphs.Graphs.smallgraph(:karate);

julia&gt; model = UBCM(G);

julia&gt; solve_model!(model);

julia&gt; set_Ĝ!(model);

julia&gt; (triangles(G), triangles(MaxEntropyGraphs.Graphs.adjacency_matrix(G)), triangles(model))
(45, 45.0, 52.849301363026846)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L562-L588">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.squares" href="#MaxEntropyGraphs.squares"><code>MaxEntropyGraphs.squares</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">squares(G::Graphs.SimpleGraph)
squares(A::T; check_dimensions::Bool=true, check_directed::Bool=true) where {T&lt;:AbstractMatrix}
squares(m::UBCM)</code></pre><p>Compute the number of (expected) squares for an undirected graph. Can be done directly from the graph, based on the adjacency matrix or a UBCM model.</p><p><strong>Notes:</strong></p><p>In this function, by <span>$square$</span>, a &#39;pure&#39; square is understood, without any diagonals inside. This explains the difference with the induced subgraph count, which counts all squares, including those with triangles inside. </p><p><strong>Arguments</strong></p><p>For the adjacency matrix <code>A</code>, the following arguments can be passed:</p><ul><li><code>check_dimensions</code>: if true, check that <code>A</code> is a square matrix, otherwise throw an error.</li><li><code>check_directed</code>: if true, check that <code>A</code> is symmetrical, otherwise throw an error.</li></ul><p>These checks can be turned off for perfomance reasons.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; G = MaxEntropyGraphs.Graphs.smallgraph(:karate);

julia&gt; model = UBCM(G);

julia&gt; solve_model!(model);

julia&gt; set_Ĝ!(model);

julia&gt; (squares(G), squares(MaxEntropyGraphs.Graphs.adjacency_matrix(G)), squares(model))
(36.0, 36.0, 45.644736823949344)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L619-L648">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.a⭢" href="#MaxEntropyGraphs.a⭢"><code>MaxEntropyGraphs.a⭢</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">a⭢(A::T, i::Int, j::Int) where T&lt;:AbstractArray</code></pre><p>Compute non-recipocrated directed link from i to j and not from j to i.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L709-L713">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.a⭠" href="#MaxEntropyGraphs.a⭠"><code>MaxEntropyGraphs.a⭠</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">a⭠(A::T, i::Int, j::Int) where T&lt;:AbstractArray</code></pre><p>Computed non-recipocrated directed link not from i to j and  from j to i.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L716-L720">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.a⭤" href="#MaxEntropyGraphs.a⭤"><code>MaxEntropyGraphs.a⭤</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">a⭤(A::T, i::Int, j::Int) where T&lt;:AbstractArray</code></pre><p>Computed recipocrated directed link between i and j.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L723-L727">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.a̲" href="#MaxEntropyGraphs.a̲"><code>MaxEntropyGraphs.a̲</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">a̲(A::T, i::Int, j::Int) where T&lt;:AbstractArray</code></pre><p>Compute absence of link between i and j.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L730-L734">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.M1" href="#MaxEntropyGraphs.M1"><code>MaxEntropyGraphs.M1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">M1(A::T) where T&lt;:AbstractArray</code></pre><p>Count the occurence of motif M1 (Σ_{i≠j≠k} a⭠(i,j) a⭢(j,k) a̲(k,i) ) from the adjacency matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L758-L762">source</a></section><section><div><pre><code class="nohighlight hljs">M1(m::DBCM)</code></pre><p>Count the occurence of motif M1 (Σ_{i≠j≠k} a⭠ (i,j) × a⭢ (j,k) × a̲ (k,i) ) from the <code>DBCM</code> model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L778-L782">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.M2" href="#MaxEntropyGraphs.M2"><code>MaxEntropyGraphs.M2</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">M2(A::T) where T&lt;:AbstractArray</code></pre><p>Count the occurence of motif M2 (Σ_{i≠j≠k} a⭠(i,j) a⭠(j,k) a̲(k,i) ) from the adjacency matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L758-L762">source</a></section><section><div><pre><code class="nohighlight hljs">M2(m::DBCM)</code></pre><p>Count the occurence of motif M2 (Σ_{i≠j≠k} a⭠ (i,j) × a⭠ (j,k) × a̲ (k,i) ) from the <code>DBCM</code> model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L778-L782">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.M3" href="#MaxEntropyGraphs.M3"><code>MaxEntropyGraphs.M3</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">M3(A::T) where T&lt;:AbstractArray</code></pre><p>Count the occurence of motif M3 (Σ_{i≠j≠k} a⭠(i,j) a⭤(j,k) a̲(k,i) ) from the adjacency matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L758-L762">source</a></section><section><div><pre><code class="nohighlight hljs">M3(m::DBCM)</code></pre><p>Count the occurence of motif M3 (Σ_{i≠j≠k} a⭠ (i,j) × a⭤ (j,k) × a̲ (k,i) ) from the <code>DBCM</code> model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L778-L782">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.M4" href="#MaxEntropyGraphs.M4"><code>MaxEntropyGraphs.M4</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">M4(A::T) where T&lt;:AbstractArray</code></pre><p>Count the occurence of motif M4 (Σ_{i≠j≠k} a⭠(i,j) a̲(j,k) a⭢(k,i) ) from the adjacency matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L758-L762">source</a></section><section><div><pre><code class="nohighlight hljs">M4(m::DBCM)</code></pre><p>Count the occurence of motif M4 (Σ_{i≠j≠k} a⭠ (i,j) × a̲ (j,k) × a⭢ (k,i) ) from the <code>DBCM</code> model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L778-L782">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.M5" href="#MaxEntropyGraphs.M5"><code>MaxEntropyGraphs.M5</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">M5(A::T) where T&lt;:AbstractArray</code></pre><p>Count the occurence of motif M5 (Σ_{i≠j≠k} a⭠(i,j) a⭢(j,k) a⭢(k,i) ) from the adjacency matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L758-L762">source</a></section><section><div><pre><code class="nohighlight hljs">M5(m::DBCM)</code></pre><p>Count the occurence of motif M5 (Σ_{i≠j≠k} a⭠ (i,j) × a⭢ (j,k) × a⭢ (k,i) ) from the <code>DBCM</code> model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L778-L782">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.M6" href="#MaxEntropyGraphs.M6"><code>MaxEntropyGraphs.M6</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">M6(A::T) where T&lt;:AbstractArray</code></pre><p>Count the occurence of motif M6 (Σ_{i≠j≠k} a⭠(i,j) a⭤(j,k) a⭢(k,i) ) from the adjacency matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L758-L762">source</a></section><section><div><pre><code class="nohighlight hljs">M6(m::DBCM)</code></pre><p>Count the occurence of motif M6 (Σ_{i≠j≠k} a⭠ (i,j) × a⭤ (j,k) × a⭢ (k,i) ) from the <code>DBCM</code> model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L778-L782">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.M7" href="#MaxEntropyGraphs.M7"><code>MaxEntropyGraphs.M7</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">M7(A::T) where T&lt;:AbstractArray</code></pre><p>Count the occurence of motif M7 (Σ_{i≠j≠k} a⭢(i,j) a⭤(j,k) a̲(k,i) ) from the adjacency matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L758-L762">source</a></section><section><div><pre><code class="nohighlight hljs">M7(m::DBCM)</code></pre><p>Count the occurence of motif M7 (Σ_{i≠j≠k} a⭢ (i,j) × a⭤ (j,k) × a̲ (k,i) ) from the <code>DBCM</code> model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L778-L782">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.M8" href="#MaxEntropyGraphs.M8"><code>MaxEntropyGraphs.M8</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">M8(A::T) where T&lt;:AbstractArray</code></pre><p>Count the occurence of motif M8 (Σ_{i≠j≠k} a⭤(i,j) a⭤(j,k) a̲(k,i) ) from the adjacency matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L758-L762">source</a></section><section><div><pre><code class="nohighlight hljs">M8(m::DBCM)</code></pre><p>Count the occurence of motif M8 (Σ_{i≠j≠k} a⭤ (i,j) × a⭤ (j,k) × a̲ (k,i) ) from the <code>DBCM</code> model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L778-L782">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.M9" href="#MaxEntropyGraphs.M9"><code>MaxEntropyGraphs.M9</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">M9(A::T) where T&lt;:AbstractArray</code></pre><p>Count the occurence of motif M9 (Σ_{i≠j≠k} a⭢(i,j) a⭢(j,k) a⭢(k,i) ) from the adjacency matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L758-L762">source</a></section><section><div><pre><code class="nohighlight hljs">M9(m::DBCM)</code></pre><p>Count the occurence of motif M9 (Σ_{i≠j≠k} a⭢ (i,j) × a⭢ (j,k) × a⭢ (k,i) ) from the <code>DBCM</code> model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L778-L782">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.M10" href="#MaxEntropyGraphs.M10"><code>MaxEntropyGraphs.M10</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">M10(A::T) where T&lt;:AbstractArray</code></pre><p>Count the occurence of motif M10 (Σ_{i≠j≠k} a⭤(i,j) a⭢(j,k) a⭢(k,i) ) from the adjacency matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L758-L762">source</a></section><section><div><pre><code class="nohighlight hljs">M10(m::DBCM)</code></pre><p>Count the occurence of motif M10 (Σ_{i≠j≠k} a⭤ (i,j) × a⭢ (j,k) × a⭢ (k,i) ) from the <code>DBCM</code> model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L778-L782">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.M11" href="#MaxEntropyGraphs.M11"><code>MaxEntropyGraphs.M11</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">M11(A::T) where T&lt;:AbstractArray</code></pre><p>Count the occurence of motif M11 (Σ_{i≠j≠k} a⭤(i,j) a⭠(j,k) a⭢(k,i) ) from the adjacency matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L758-L762">source</a></section><section><div><pre><code class="nohighlight hljs">M11(m::DBCM)</code></pre><p>Count the occurence of motif M11 (Σ_{i≠j≠k} a⭤ (i,j) × a⭠ (j,k) × a⭢ (k,i) ) from the <code>DBCM</code> model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L778-L782">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.M12" href="#MaxEntropyGraphs.M12"><code>MaxEntropyGraphs.M12</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">M12(A::T) where T&lt;:AbstractArray</code></pre><p>Count the occurence of motif M12 (Σ_{i≠j≠k} a⭤(i,j) a⭤(j,k) a⭢(k,i) ) from the adjacency matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L758-L762">source</a></section><section><div><pre><code class="nohighlight hljs">M12(m::DBCM)</code></pre><p>Count the occurence of motif M12 (Σ_{i≠j≠k} a⭤ (i,j) × a⭤ (j,k) × a⭢ (k,i) ) from the <code>DBCM</code> model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L778-L782">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.M13" href="#MaxEntropyGraphs.M13"><code>MaxEntropyGraphs.M13</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">M13(A::T) where T&lt;:AbstractArray</code></pre><p>Count the occurence of motif M13 (Σ_{i≠j≠k} a⭤(i,j) a⭤(j,k) a⭤(k,i) ) from the adjacency matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L758-L762">source</a></section><section><div><pre><code class="nohighlight hljs">M13(m::DBCM)</code></pre><p>Count the occurence of motif M13 (Σ_{i≠j≠k} a⭤ (i,j) × a⭤ (j,k) × a⭤ (k,i) ) from the <code>DBCM</code> model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/utils.jl#L778-L782">source</a></section></article><h2 id="UBCM"><a class="docs-heading-anchor" href="#UBCM">UBCM</a><a id="UBCM-1"></a><a class="docs-heading-anchor-permalink" href="#UBCM" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.UBCM" href="#MaxEntropyGraphs.UBCM"><code>MaxEntropyGraphs.UBCM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UBCM</code></pre><p>Maximum entropy model for the Undirected Binary Configuration Model (UBCM). </p><p>The object holds the maximum likelihood parameters of the model (θ) and optionally the expected adjacency matrix (G),  and the variance for the elements of the adjacency matrix (σ). All settings and other metadata are stored in the <code>status</code> field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/UBCM.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.UBCM-Tuple{T} where T" href="#MaxEntropyGraphs.UBCM-Tuple{T} where T"><code>MaxEntropyGraphs.UBCM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">UBCM(G::T; d::Vector=Graphs.degree(G), precision::N=Float64, kwargs...) where {T&lt;:Graphs.AbstractGraph, N&lt;:Real}
UBCM(d::Vector{T}, precision::Type{&lt;:AbstractFloat}=Float64, kwargs...)</code></pre><p>Constructor function for the <code>UBCM</code> type. </p><p>By default and dependng on the graph type <code>T</code>, the definition of degree from <code>Graphs.jl</code> is applied.  If you want to use a different definition of degree, you can pass a vector of degrees as the second argument. If you want to generate a model directly from a degree sequence without an underlying graph, you can simply pass the degree sequence as an argument. If you want to work from an adjacency matrix, or edge list, you can use the graph constructors from the <code>JuliaGraphs</code> ecosystem.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># generating a model from a graph
julia&gt; G = MaxEntropyGraphs.Graphs.SimpleGraphs.smallgraph(:karate)
{34, 78} undirected simple Int64 graph
julia&gt; model = UBCM(G)
UBCM{Graphs.SimpleGraphs.SimpleGraph{Int64}, Float64} (34 vertices, 11 unique degrees, 0.32 compression ratio)</code></pre><pre><code class="language-julia-repl hljs"># generating a model directly from a degree sequence
julia&gt; model = UBCM(d=[4;3;3;3;2])
UBCM{Nothing, Float64} (5 vertices, 3 unique degrees, 0.60 compression ratio)</code></pre><pre><code class="language-julia-repl hljs"># generating a model directly from a degree sequence with a different precision
julia&gt; model = UBCM(d=[4;3;3;3;2], precision=Float16)
UBCM{Nothing, Float16} (5 vertices, 3 unique degrees, 0.60 compression ratio)</code></pre><pre><code class="language-julia-repl hljs"># generating a model from an adjacency matrix
julia&gt; A = [0 1 1;1 0 0;1 0 0];

julia&gt; G = MaxEntropyGraphs.Graphs.SimpleGraph(A)
{3, 2} undirected simple Int64 graph
julia&gt; model = UBCM(G)
UBCM{Graphs.SimpleGraphs.SimpleGraph{Int64}, Float64} (3 vertices, 2 unique degrees, 0.67 compression ratio)</code></pre><pre><code class="language-julia-repl hljs"># generating a model from an edge list
julia&gt; E = [(1,2),(1,3),(2,3)];

julia&gt; edgelist = [MaxEntropyGraphs.Graphs.Edge(x,y) for (x,y) in E];

julia&gt; G = MaxEntropyGraphs.Graphs.SimpleGraphFromIterator(edgelist)
{3, 3} undirected simple Int64 graph
julia&gt; model = UBCM(G)
UBCM{Graphs.SimpleGraphs.SimpleGraph{Int64}, Float64} (3 vertices, 1 unique degrees, 0.33 compression ratio)</code></pre><p>See also <a href="https://juliagraphs.org/Graphs.jl/stable/core_functions/core/#Graphs.degree"><code>Graphs.degree</code></a>, <a href="https://juliagraphs.org/SimpleWeightedGraphs.jl/stable/api/#Graphs.inneighbors-Tuple{SimpleWeightedDiGraph,%20Integer}"><code>SimpleWeightedGraphs.inneighbors</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/UBCM.jl#L44-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.solve_model!-Tuple{UBCM}" href="#MaxEntropyGraphs.solve_model!-Tuple{UBCM}"><code>MaxEntropyGraphs.solve_model!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve_model!(m::UBCM; kwargs...)</code></pre><p>Compute the likelihood maximising parameters of the UBCM model <code>m</code>. </p><p><strong>Arguments</strong></p><ul><li><code>method::Symbol</code>: solution method to use, can be <code>:fixedpoint</code> (default), or :NelderMead, :BFGS, :LBFGS and :Newton.</li><li><code>initial::Symbol</code>: initial guess for the parameters <span>$\Theta$</span>, can be :degrees, :degrees<em>minor, :random, :uniform, or :chung</em>lu.</li><li><code>maxiters::Int</code>: maximum number of iterations for the solver (defaults to 1000). </li><li><code>verbose::Bool</code>: set to show log messages (defaults to false).</li><li><code>ftol::Real</code>: function tolerance for convergence with the fixedpoint method (defaults to 1e-8).</li><li><code>abstol::Union{Number, Nothing}</code>: absolute function tolerance for convergence with the other methods (defaults to <code>nothing</code>).</li><li><code>reltol::Union{Number, Nothing}</code>: relative function tolerance for convergence with the other methods (defaults to <code>nothing</code>).</li><li><code>AD_method::Symbol</code>: autodiff method to use, can be any of :AutoZygote, :AutoReverseDiff, :AutoForwardDiff and :AutoFiniteDiff. Performance depends on the size of the problem (defaults to <code>:AutoZygote</code>),</li><li><code>analytical_gradient::Bool</code>: set the use the analytical gradient instead of the one generated with autodiff (defaults to <code>false</code>)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># default use
julia&gt; model = UBCM(MaxEntropyGraphs.Graphs.SimpleGraphs.smallgraph(:karate));

julia&gt; solve_model!(model);
</code></pre><pre><code class="language-julia-repl hljs"># using analytical gradient and degrees minor initial guess
julia&gt; solve_model!(model, method=:BFGS, analytical_gradient=true, initial=:degrees_minor)
(UBCM{Graphs.SimpleGraphs.SimpleGraph{Int64}, Float64} (34 vertices, 11 unique degrees, 0.32 compression ratio), retcode: Success
u: [2.851659905903854, 2.053008374573552, 1.5432639513870743, 1.152360118212239, 0.8271267490690292, 0.5445045274064909, -0.1398726818076551, -0.3293252270659469, -0.6706207459338859, -1.2685575582149227, -1.410096540372487]
Final objective value:     168.68325136302835
)
</code></pre><p>See also: <a href="#MaxEntropyGraphs.initial_guess-Tuple{UBCM}"><code>initial_guess</code></a>, <a href="#MaxEntropyGraphs.∇L_UBCM_reduced!"><code>∇L_UBCM_reduced!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/UBCM.jl#L631-L666">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.initial_guess-Tuple{UBCM}" href="#MaxEntropyGraphs.initial_guess-Tuple{UBCM}"><code>MaxEntropyGraphs.initial_guess</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_guess(m::UBCM, method::Symbol=:degrees)</code></pre><p>Compute an initial guess for the maximum likelihood parameters of the UBCM model <code>m</code> using the method <code>method</code>.</p><p>The methods available are: </p><ul><li><code>:degrees</code> (default): the initial guess is computed using the degrees of the graph, i.e. <span>$\theta_{i} = -\log(d_{i})$</span> </li><li><code>:degrees_minor</code>: the initial guess is computed using the degrees of the graph and the number of edges, i.e. <span>$\theta_{i} = -\log(d_{i}/(\sqrt{E} + 1))$</span></li><li><code>:random</code>: the initial guess is computed using random values between 0 and 1, i.e. <span>$\theta_{i} = -\log(r_{i})$</span> where <span>$r_{i} \sim U(0,1)$</span></li><li><code>:uniform</code>: the initial guess is uniformily set to 0.5, i.e. <span>$\theta_{i} = -\log(0.5)$</span></li><li><code>:chung_lu</code>: the initial guess is computed using the degrees of the graph and the number of edges, i.e. <span>$\theta_{i} = -\log(d_{i}/(2E))$</span></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = UBCM(MaxEntropyGraphs.Graphs.SimpleGraphs.smallgraph(:karate));

julia&gt; initial_guess(model, method=:random);

julia&gt; initial_guess(model, method=:uniform);

julia&gt; initial_guess(model, method=:degrees_minor);

julia&gt; initial_guess(model, method=:chung_lu);

julia&gt; initial_guess(model)
11-element Vector{Float64}:
 -0.0
 -0.6931471805599453
 -1.0986122886681098
 -1.3862943611198906
 -1.6094379124341003
 -1.791759469228055
 -2.1972245773362196
 -2.302585092994046
 -2.4849066497880004
 -2.772588722239781
 -2.833213344056216
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/UBCM.jl#L401-L440">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rand-Tuple{UBCM}" href="#Base.rand-Tuple{UBCM}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand(m::UBCM; precomputed=false)</code></pre><p>Generate a random graph from the UBCM model <code>m</code>.</p><p><strong>Arguments</strong></p><ul><li><code>precomputed::Bool</code>: if <code>true</code>, the precomputed expected adjacency matrix (<code>m.Ĝ</code>) is used to generate the random graph, otherwise the maximum likelihood parameters are used to generate the random graph on the fly. For larger networks, it is  recommended to not precompute the expected adjacency matrix to limit memory pressure.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = UBCM(MaxEntropyGraphs.Graphs.SimpleGraphs.smallgraph(:karate)); # generate a UBCM model from the karate club network

julia&gt; solve_model!(model); # compute the maximum likelihood parameters

julia&gt; sample = rand(model); # sample a random graph

julia&gt; typeof(sample)
Graphs.SimpleGraphs.SimpleGraph{Int64}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/UBCM.jl#L553-L573">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rand-Tuple{UBCM, Int64}" href="#Base.rand-Tuple{UBCM, Int64}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand(m::UBCM, n::Int; precomputed=false)</code></pre><p>Generate <code>n</code> random graphs from the UBCM model <code>m</code>. If multithreading is available, the graphs are generated in parallel.</p><p><strong>Arguments</strong></p><ul><li><code>precomputed::Bool</code>: if <code>true</code>, the precomputed expected adjacency matrix (<code>m.Ĝ</code>) is used to generate the random graph, otherwise the maximum likelihood parameters are used to generate the random graph on the fly. For larger networks, it is  recommended to not precompute the expected adjacency matrix to limit memory pressure.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = UBCM(MaxEntropyGraphs.Graphs.SimpleGraphs.smallgraph(:karate)); # generate a UBCM model from the karate club network

julia&gt; solve_model!(model); # compute the maximum likelihood parameters

julia&gt; sample = rand(model, 10); # sample a set of random graphs

julia&gt; typeof(sample)
Vector{SimpleGraph{Int64}} (alias for Array{Graphs.SimpleGraphs.SimpleGraph{Int64}, 1})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/UBCM.jl#L598-L618">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.AIC-Tuple{UBCM}" href="#MaxEntropyGraphs.AIC-Tuple{UBCM}"><code>MaxEntropyGraphs.AIC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AIC(m::UBCM)</code></pre><p>Compute the Akaike Information Criterion (AIC) for the UBCM model <code>m</code>. The parameters of the models most be computed beforehand.  If the number of empirical observations becomes too small with respect to the number of parameters, you will get a warning. In  that case, the corrected AIC (AICc) should be used instead.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; model = UBCM(MaxEntropyGraphs.Graphs.SimpleGraphs.smallgraph(:karate));

julia&gt; solve_model!(model);

julia&gt; AIC(model);
[...]
</code></pre><p>See also <a href="#MaxEntropyGraphs.AICc-Tuple{UBCM}"><code>AICc</code></a>, <a href="#MaxEntropyGraphs.L_UBCM_reduced"><code>L_UBCM_reduced</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/UBCM.jl#L863-L882">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.AICc-Tuple{UBCM}" href="#MaxEntropyGraphs.AICc-Tuple{UBCM}"><code>MaxEntropyGraphs.AICc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AICc(m::UBCM)</code></pre><p>Compute the corrected Akaike Information Criterion (AICc) for the UBCM model <code>m</code>. The parameters of the models most be computed beforehand. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = UBCM(MaxEntropyGraphs.Graphs.SimpleGraphs.smallgraph(:karate));

julia&gt; solve_model!(model);

julia&gt; AICc(model)
409.891217554954
</code></pre><p>See also <a href="#MaxEntropyGraphs.AIC-Tuple{UBCM}"><code>AIC</code></a>, <a href="#MaxEntropyGraphs.L_UBCM_reduced"><code>L_UBCM_reduced</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/UBCM.jl#L899-L917">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.BIC-Tuple{UBCM}" href="#MaxEntropyGraphs.BIC-Tuple{UBCM}"><code>MaxEntropyGraphs.BIC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BIC(m::UBCM)</code></pre><p>Compute the Bayesian Information Criterion (BIC) for the UBCM model <code>m</code>. The parameters of the models most be computed beforehand.  BIC is believed to be more restrictive than AIC, as the former favors models with a lower number of parameters than those favored by the latter.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = UBCM(MaxEntropyGraphs.Graphs.SimpleGraphs.smallgraph(:karate));

julia&gt; solve_model!(model);

julia&gt; BIC(model)
552.5770135138283
</code></pre><p>See also <a href="#MaxEntropyGraphs.AIC-Tuple{UBCM}"><code>AIC</code></a>, <a href="#MaxEntropyGraphs.L_UBCM_reduced"><code>L_UBCM_reduced</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/UBCM.jl#L930-L948">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{UBCM}" href="#Base.length-Tuple{UBCM}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the reduced number of nodes in the UBCM network</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/UBCM.jl#L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.L_UBCM_reduced" href="#MaxEntropyGraphs.L_UBCM_reduced"><code>MaxEntropyGraphs.L_UBCM_reduced</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">L_UBCM_reduced(θ::Vector, K::Vector, F::Vector)</code></pre><p>Compute the log-likelihood of the reduced UBCM model using the exponential formulation in order to maintain convexity.</p><p><strong>Arguments</strong></p><ul><li><code>θ</code>: the maximum likelihood parameters of the model</li><li><code>K</code>: the reduced degree sequence</li><li><code>F</code>: the frequency of each degree in the degree sequence</li></ul><p>The function returns the log-likelihood of the reduced model. For the optimisation, this function will be used to generate an anonymous function associated with a specific model.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># Generic use:
julia&gt; θ = [1.0, 2.0, 3.0, 4.0, 5.0];

julia&gt; K = [1, 2, 3, 4, 5];

julia&gt; F = [1, 2, 3, 4, 5];

julia&gt; L_UBCM_reduced(θ, K, F)
-225.3065566905141</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/UBCM.jl#L140-L165">source</a></section><section><div><pre><code class="nohighlight hljs">L_UBCM_reduced(m::UBCM)</code></pre><p>Return the log-likelihood of the UBCM model <code>m</code> based on the computed maximum likelihood parameters.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># Use with UBCM model:
julia&gt; G = MaxEntropyGraphs.Graphs.SimpleGraphs.smallgraph(:karate);

julia&gt; model = UBCM(G);

julia&gt; solve_model!(model);

julia&gt; L_UBCM_reduced(model)
-168.68325136302832</code></pre><p>See also <a href="#MaxEntropyGraphs.L_UBCM_reduced"><code>L_UBCM_reduced(::Vector, ::Vector, ::Vector)</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/UBCM.jl#L184-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.∇L_UBCM_reduced!" href="#MaxEntropyGraphs.∇L_UBCM_reduced!"><code>MaxEntropyGraphs.∇L_UBCM_reduced!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">∇L_UBCM_reduced!(∇L::Vector, θ::Vector, K::Vector, F::Vector, x::Vector)</code></pre><p>Compute the gradient of the log-likelihood of the reduced UBCM model using the exponential formulation (to maintain convexity).</p><p>For the optimisation, this function will be used togenerate an anonymous function associated with a specific model.  The gradient is non-allocating and will update pre-allocated vectors (<code>∇L</code> and <code>x</code>) for speed. </p><p><strong>Arguments</strong></p><ul><li><code>∇L</code>: the gradient of the log-likelihood of the reduced model</li><li><code>θ</code>: the maximum likelihood parameters of the model</li><li><code>K</code>: the reduced degree sequence</li><li><code>F</code>: the frequency of each degree in the degree sequence</li><li><code>x</code>: the exponentiated maximum likelihood parameters of the model ( xᵢ = exp(-θᵢ) )</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># Explicit use with UBCM model:
julia&gt; G = MaxEntropyGraphs.Graphs.SimpleGraphs.smallgraph(:karate);

julia&gt; model = UBCM(G);

julia&gt; ∇L = zeros(Real, length(model.θᵣ));

julia&gt; x  = zeros(Real, length(model.θᵣ));

julia&gt; ∇model_fun! = θ -&gt; ∇L_UBCM_reduced!(∇L, θ, model.dᵣ, model.f, x);

julia&gt; ∇model_fun!(model.θᵣ);
</code></pre><pre><code class="language-julia-repl hljs"># Use within optimisation.jl framework:
julia&gt; model = UBCM(MaxEntropyGraphs.Graphs.SimpleGraphs.smallgraph(:karate));

julia&gt; fun =  (θ, p) -&gt;  - L_UBCM_reduced(θ, model.dᵣ, model.f);

julia&gt; x  = zeros(Real, length(model.θᵣ)); # initialise gradient buffer

julia&gt; ∇fun! = (∇L, θ, p) -&gt; ∇L_UBCM_reduced!(∇L, θ, model.dᵣ, model.f, x); # define gradient

julia&gt; θ₀ = initial_guess(model); # initial condition

julia&gt; foo = MaxEntropyGraphs.Optimization.OptimizationFunction(fun, grad=∇fun!); # define target function 

julia&gt; prob  = MaxEntropyGraphs.Optimization.OptimizationProblem(foo, θ₀); # define the optimisation problem

julia&gt; method = MaxEntropyGraphs.OptimizationOptimJL.LBFGS(); # set the optimisation method

julia&gt; MaxEntropyGraphs.Optimization.solve(prob, method); # solve it
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/UBCM.jl#L212-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.∇L_UBCM_reduced_minus!" href="#MaxEntropyGraphs.∇L_UBCM_reduced_minus!"><code>MaxEntropyGraphs.∇L_UBCM_reduced_minus!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">∇L_UBCM_reduced_minus!(args...)</code></pre><p>Compute minus the gradient of the log-likelihood of the reduced UBCM model using the exponential formulation in order to maintain convexity. Used for optimisation in a non-allocating manner.</p><p>See also <a href="#MaxEntropyGraphs.∇L_UBCM_reduced!"><code>∇L_UBCM_reduced!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/UBCM.jl#L287-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.UBCM_reduced_iter!" href="#MaxEntropyGraphs.UBCM_reduced_iter!"><code>MaxEntropyGraphs.UBCM_reduced_iter!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">UBCM_reduced_iter!(θ, K, F, x, G)</code></pre><p>Computer the next fixed-point iteration for the UBCM model using the exponential formulation in order to maintain convexity. The function will update pre-allocated vectors (<code>G</code> and <code>x</code>) for speed.</p><p><strong>Arguments</strong></p><ul><li><code>θ</code>: the maximum likelihood parameters of the model</li><li><code>K</code>: the reduced degree sequence</li><li><code>F</code>: the frequency of each degree in the degree sequence</li><li><code>x</code>: the exponentiated maximum likelihood parameters of the model ( xᵢ = exp(-θᵢ) ) (pre-allocated)</li><li><code>G</code>: the next fixed-point iteration for the UBCM model (pre-allocated)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = UBCM(MaxEntropyGraphs.Graphs.SimpleGraphs.smallgraph(:karate));

julia&gt; G = zeros(eltype(model.θᵣ), length(model.θᵣ));

julia&gt; x = zeros(eltype(model.θᵣ), length(model.θᵣ));

julia&gt; UBCM_FP! = θ -&gt; UBCM_reduced_iter!(θ, model.dᵣ, model.f, x, G);

julia&gt; UBCM_FP!(initial_guess(model));
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/UBCM.jl#L315-L342">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.set_xᵣ!-Tuple{UBCM}" href="#MaxEntropyGraphs.set_xᵣ!-Tuple{UBCM}"><code>MaxEntropyGraphs.set_xᵣ!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_xᵣ!(m::UBCM)</code></pre><p>Set the value of xᵣ to exp(-θᵣ) for the UBCM model <code>m</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/UBCM.jl#L461-L465">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.Ĝ-Tuple{UBCM}" href="#MaxEntropyGraphs.Ĝ-Tuple{UBCM}"><code>MaxEntropyGraphs.Ĝ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Ĝ(m::UBCM)</code></pre><p>Compute the expected adjacency matrix for the UBCM model <code>m</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/UBCM.jl#L475-L479">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.set_Ĝ!-Tuple{UBCM}" href="#MaxEntropyGraphs.set_Ĝ!-Tuple{UBCM}"><code>MaxEntropyGraphs.set_Ĝ!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_Ĝ!(m::UBCM)</code></pre><p>Set the expected adjacency matrix for the UBCM model <code>m</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/UBCM.jl#L502-L506">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.σˣ-Tuple{UBCM}" href="#MaxEntropyGraphs.σˣ-Tuple{UBCM}"><code>MaxEntropyGraphs.σˣ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">σˣ(m::UBCM{T,N}) where {T,N}</code></pre><p>Compute the standard deviation for the elements of the adjacency matrix for the UBCM model <code>m</code>.</p><p><strong>Note:</strong> read as &quot;sigma star&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/UBCM.jl#L514-L520">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.set_σ!-Tuple{UBCM}" href="#MaxEntropyGraphs.set_σ!-Tuple{UBCM}"><code>MaxEntropyGraphs.set_σ!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_σ!(m::UBCM)</code></pre><p>Set the standard deviation for the elements of the adjacency matrix for the UBCM model <code>m</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/UBCM.jl#L542-L546">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.precision-Tuple{UBCM}" href="#Base.precision-Tuple{UBCM}"><code>Base.precision</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">precision(m::UBCM)</code></pre><p>Determine the compute precision of the UBCM model <code>m</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = UBCM(MaxEntropyGraphs.Graphs.SimpleGraphs.smallgraph(:karate));

julia&gt; MaxEntropyGraphs.precision(model)
Float64</code></pre><pre><code class="language-julia-repl hljs">julia&gt; model = UBCM(MaxEntropyGraphs.Graphs.SimpleGraphs.smallgraph(:karate), precision=Float32);

julia&gt; MaxEntropyGraphs.precision(model)
Float32</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/UBCM.jl#L730-L749">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.A-Tuple{UBCM, Int64, Int64}" href="#MaxEntropyGraphs.A-Tuple{UBCM, Int64, Int64}"><code>MaxEntropyGraphs.A</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">A(m::UBCM,i::Int,j::Int)</code></pre><p>Return the expected value of the adjacency matrix for the UBCM model <code>m</code> at the node pair <code>(i,j)</code>.</p><p>❗ For perfomance reasons, the function does not check:</p><ul><li>if the node pair is valid.</li><li>if the parameters of the model have been computed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/UBCM.jl#L762-L770">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.f_UBCM-Tuple{UBCM}" href="#MaxEntropyGraphs.f_UBCM-Tuple{UBCM}"><code>MaxEntropyGraphs.f_UBCM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">f_UBCM(x::T)</code></pre><p>Helper function for the UBCM model to compute the expected value of the adjacency matrix. The function computes the expression <code>x / (1 + x)</code>. As an argument you need to pass the product of the maximum likelihood parameters <code>xᵣ[i] * xᵣ[j]</code> from a UBCM model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/UBCM.jl#L753-L758">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.σₓ-Tuple{UBCM, Function}" href="#MaxEntropyGraphs.σₓ-Tuple{UBCM, Function}"><code>MaxEntropyGraphs.σₓ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">σₓ(m::UBCM, X::function)</code></pre><p>Compute the standard deviation of metric <code>X</code> for the UBCM model <code>m</code>. </p><p>This requires that both the expected values (m.Ĝ) and standard deviations (m.σ) are computed for <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/UBCM.jl#L962-L968">source</a></section></article><h2 id="DBCM"><a class="docs-heading-anchor" href="#DBCM">DBCM</a><a id="DBCM-1"></a><a class="docs-heading-anchor-permalink" href="#DBCM" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.DBCM" href="#MaxEntropyGraphs.DBCM"><code>MaxEntropyGraphs.DBCM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DBCM</code></pre><p>Maximum entropy model for the Directed Binary Configuration Model (UBCM).</p><p>The object holds the maximum likelihood parameters of the model (θ) and optionally the expected adjacency matrix (G),  and the variance for the elements of the adjacency matrix (σ). All settings and other metadata are stored in the <code>status</code> field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/DBCM.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.DBCM-Tuple{T} where T" href="#MaxEntropyGraphs.DBCM-Tuple{T} where T"><code>MaxEntropyGraphs.DBCM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DBCM(G::T; precision::N=Float64, kwargs...) where {T&lt;:Graphs.AbstractGraph, N&lt;:Real}
DBCM(;d_out::Vector{T}, d_in::Vector{T}, precision::Type{&lt;:AbstractFloat}=Float64, kwargs...)</code></pre><p>Constructor function for the <code>DBCM</code> type. </p><p>By default and dependng on the graph type <code>T</code>, the definition of in- and outdegree from <span>$Graphs.jl$</span> is applied.  If you want to use a different definition of degrees, you can pass vectors of degrees sequences as keyword arguments (<code>d_out</code>, <code>d_in</code>). If you want to generate a model directly from degree sequences without an underlying graph, you can simply pass the degree sequences as arguments (<code>d_out</code>, <code>d_in</code>). If you want to work from an adjacency matrix, or edge list, you can use the graph constructors from the <span>$JuliaGraphs$</span> ecosystem.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># generating a model from a graph
julia&gt; G = MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques())
{16, 111} directed simple Int64 graph
julia&gt; model = DBCM(G)
DBCM{Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Float64} (16 vertices, 15 unique degree pairs, 0.94 compression ratio)</code></pre><pre><code class="language-julia-repl hljs"># generating a model directly from a degree sequence
julia&gt; model = DBCM(d_out=MaxEntropyGraphs.Graphs.outdegree(G), d_in=MaxEntropyGraphs.Graphs.indegree(G))
DBCM{Nothing, Float64} (16 vertices, 15 unique degree pairs, 0.94 compression ratio)</code></pre><pre><code class="language-julia-repl hljs"># generating a model directly from a degree sequence with a different precision
julia&gt;  model = DBCM(d_out=MaxEntropyGraphs.Graphs.outdegree(G), d_in=MaxEntropyGraphs.Graphs.indegree(G), precision=Float32)
DBCM{Nothing, Float32} (16 vertices, 15 unique degree pairs, 0.94 compression ratio)</code></pre><pre><code class="language-julia-repl hljs"># generating a model from an adjacency matrix
julia&gt; A = [0 1 1;1 0 0;1 1 0];

julia&gt; G = MaxEntropyGraphs.Graphs.SimpleDiGraph(A)
{3, 5} directed simple Int64 graph
julia&gt; model = DBCM(G)
DBCM{Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Float64} (3 vertices, 3 unique degree pairs, 1.00 compression ratio)</code></pre><pre><code class="language-julia-repl hljs"># generating a model from an edge list
julia&gt; E = [(1,2),(1,3),(2,3)];

julia&gt; edgelist = [MaxEntropyGraphs.Graphs.Edge(x,y) for (x,y) in E];

julia&gt; G = MaxEntropyGraphs.Graphs.SimpleDiGraphFromIterator(edgelist)
{3, 3} directed simple Int64 graph
julia&gt; model = DBCM(G)
DBCM{Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Float64} (3 vertices, 3 unique degree pairs, 1.00 compression ratio)
</code></pre><p>See also <a href="https://juliagraphs.org/Graphs.jl/stable/core_functions/core/#Graphs.outdegree-Tuple{AbstractGraph,%20Integer}"><code>Graphs.outdegree</code></a>, <a href="https://juliagraphs.org/Graphs.jl/stable/core_functions/core/#Graphs.indegree-Tuple{AbstractGraph,%20Integer}"><code>Graphs.indegree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/DBCM.jl#L54-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.solve_model!-Tuple{DBCM}" href="#MaxEntropyGraphs.solve_model!-Tuple{DBCM}"><code>MaxEntropyGraphs.solve_model!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve_model!(m::DBCM)</code></pre><p>Compute the likelihood maximising parameters of the DBCM model <code>m</code>. </p><p><strong>Arguments</strong></p><ul><li><code>method::Symbol</code>: solution method to use, can be <code>:fixedpoint</code> (default), or :NelderMead, :BFGS, :LBFGS and :Newton.</li><li><code>initial::Symbol</code>: initial guess for the parameters <span>$\Theta$</span>, can be :degrees (default), :degrees<em>minor, :random, :uniform, or :chung</em>lu.</li><li><code>maxiters::Int</code>: maximum number of iterations for the solver (defaults to 1000). </li><li><code>verbose::Bool</code>: set to show log messages (defaults to false).</li><li><code>ftol::Real</code>: function tolerance for convergence with the fixedpoint method (defaults to 1e-8).</li><li><code>abstol::Union{Number, Nothing}</code>: absolute function tolerance for convergence with the other methods (defaults to <code>nothing</code>).</li><li><code>reltol::Union{Number, Nothing}</code>: relative function tolerance for convergence with the other methods (defaults to <code>nothing</code>).</li><li><code>AD_method::Symbol</code>: autodiff method to use, can be any of :AutoZygote, :AutoReverseDiff, :AutoForwardDiff and :AutoFiniteDiff. Performance depends on the size of the problem (defaults to <code>:AutoZygote</code>),</li><li><code>analytical_gradient::Bool</code>: set the use the analytical gradient instead of the one generated with autodiff (defaults to <code>false</code>)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># default use
julia&gt; model = DBCM(MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques()));

julia&gt; solve_model!(model);
</code></pre><pre><code class="language-julia-repl hljs"># using analytical gradient and degrees minor initial guess
julia&gt; solve_model!(model, method=:BFGS, analytical_gradient=true, initial=:degrees_minor)
(DBCM{Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Float64} (16 vertices, 15 unique degree pairs, 0.94 compression ratio), retcode: Success
u: [3.118482950362848, 2.2567400402511617, 2.2467332710940333, 0.8596258292464105, 0.4957550197436504, 0.3427782029923598, 0.126564995232929, -0.3127732185244699, -0.3967757456352901, -0.43450987676209596  …  -0.5626916621021604, 1.223396713832784, 0.10977479732876981, -1.0367565290851806, -2.0427364999923148, -0.650376357149203, -1.5165614611776657, 0.7532475835319463, 0.39856890694767605, -0.6704522097652438]
Final objective value:     120.15942408828177
)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/DBCM.jl#L752-L785">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.initial_guess-Tuple{DBCM}" href="#MaxEntropyGraphs.initial_guess-Tuple{DBCM}"><code>MaxEntropyGraphs.initial_guess</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_guess(m::DBCM, method::Symbol=:degrees)</code></pre><p>Compute an initial guess for the maximum likelihood parameters of the DBCM model <code>m</code> using the method <code>method</code>.</p><p>The methods available are: </p><ul><li><code>:degrees</code> (default): the initial guess is computed using the degrees of the graph, i.e. <span>$\theta = [-\log(d_{out}); -\log(d_{in})]$</span> </li><li><code>:degrees_minor</code>: the initial guess is computed using the degrees of the graph and the number of edges, i.e. <span>$\theta = [-\log(d_{out}/(\sqrt{E} + 1)); -\log(d_{in}//(\sqrt{E} + 1) )]$</span></li><li><code>:random</code>: the initial guess is computed using random values between 0 and 1, i.e. <span>$\theta_{i} = -\log(r_{i})$</span> where <span>$r_{i} \sim U(0,1)$</span></li><li><code>:uniform</code>: the initial guess is uniformily set to 0.5, i.e. <span>$\theta_{i} = -\log(0.5)$</span></li><li><code>:chung_lu</code>: the initial guess is computed using the degrees of the graph and the number of edges, i.e. <span>$\theta = [-\log(d_{out}/(2E)); -\log(d_{in}/(2E))]$</span></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = DBCM(MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques()));

julia&gt; initial_guess(model, method=:random);

julia&gt; initial_guess(model, method=:uniform);

julia&gt; initial_guess(model, method=:degrees_minor);

julia&gt; initial_guess(model, method=:chung_lu);

julia&gt; initial_guess(model);
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/DBCM.jl#L504-L531">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rand-Tuple{DBCM}" href="#Base.rand-Tuple{DBCM}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand(m::DBCM; precomputed=false)</code></pre><p>Generate a random graph from the DBCM model <code>m</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>precomputed::Bool</code>: if <code>true</code>, the precomputed expected adjacency matrix (<code>m.Ĝ</code>) is used to generate the random graph, otherwise the maximum likelihood parameters are used to generate the random graph on the fly. For larger networks, it is  recommended to not precompute the expected adjacency matrix to limit memory pressure.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># generate a DBCM model macaques network
julia&gt; G = MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques());

julia&gt; model = DBCM(G); 

julia&gt; solve_model!(model); # compute the maximum likelihood parameters

julia&gt; typeof(rand(model))
Graphs.SimpleGraphs.SimpleDiGraph{Int64}
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/DBCM.jl#L665-L687">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rand-Tuple{DBCM, Int64}" href="#Base.rand-Tuple{DBCM, Int64}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand(m::DBCM, n::Int; precomputed=false)</code></pre><p>Generate <code>n</code> random graphs from the DBCM model <code>m</code>. If multithreading is available, the graphs are generated in parallel.</p><p><strong>Arguments</strong></p><ul><li><code>precomputed::Bool</code>: if <code>true</code>, the precomputed expected adjacency matrix (<code>m.Ĝ</code>) is used to generate the random graph, otherwise the maximum likelihood parameters are used to generate the random graph on the fly. For larger networks, it is  recommended to not precompute the expected adjacency matrix to limit memory pressure.</li></ul><p><strong>Examples</strong></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># generate a DBCM model macaques network
julia&gt; G = MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques());

julia&gt; model = DBCM(G); 

julia&gt; solve_model!(model); # compute the maximum likelihood parameters

julia&gt; typeof(rand(model, 10))
Vector{SimpleDiGraph{Int64}} (alias for Array{Graphs.SimpleGraphs.SimpleDiGraph{Int64}, 1})
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/DBCM.jl#L715-L738">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.AIC-Tuple{DBCM}" href="#MaxEntropyGraphs.AIC-Tuple{DBCM}"><code>MaxEntropyGraphs.AIC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AIC(m::DBCM)</code></pre><p>Compute the Akaike Information Criterion (AIC) for the DBCM model <code>m</code>. The parameters of the models most be computed beforehand.  If the number of empirical observations becomes too small with respect to the number of parameters, you will get a warning. In  that case, the corrected AIC (AICc) should be used instead.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = DBCM(MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques()));

julia&gt; solve_model!(model);

julia&gt; AIC(model);
┌ Warning: The number of observations is small with respect to the number of parameters (n/k &lt; 40). Consider using the corrected AIC (AICc) instead.
[...]
</code></pre><p>See also <a href="#MaxEntropyGraphs.AICc-Tuple{UBCM}"><code>AICc</code></a>, <a href="#MaxEntropyGraphs.L_DBCM_reduced"><code>L_DBCM_reduced</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/DBCM.jl#L1139-L1159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.AICc-Tuple{DBCM}" href="#MaxEntropyGraphs.AICc-Tuple{DBCM}"><code>MaxEntropyGraphs.AICc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AICc(m::DBCM)</code></pre><p>Compute the corrected Akaike Information Criterion (AICc) for the DBCM model <code>m</code>. The parameters of the models most be computed beforehand. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = DBCM(MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques()));

julia&gt; solve_model!(model);

julia&gt; AICc(model)
314.5217467272881
</code></pre><p>See also <a href="#MaxEntropyGraphs.AIC-Tuple{UBCM}"><code>AIC</code></a>, <a href="#MaxEntropyGraphs.L_DBCM_reduced"><code>L_DBCM_reduced</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/DBCM.jl#L1177-L1195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.BIC-Tuple{DBCM}" href="#MaxEntropyGraphs.BIC-Tuple{DBCM}"><code>MaxEntropyGraphs.BIC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BIC(m::DBCM)</code></pre><p>Compute the Bayesian Information Criterion (BIC) for the DBCM model <code>m</code>. The parameters of the models most be computed beforehand.  BIC is believed to be more restrictive than AIC, as the former favors models with a lower number of parameters than those favored by the latter.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = DBCM(MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques()));

julia&gt; solve_model!(model);

julia&gt; BIC(model)
415.69929372350714
</code></pre><p>See also <a href="#MaxEntropyGraphs.AIC-Tuple{UBCM}"><code>AIC</code></a>, <a href="#MaxEntropyGraphs.L_DBCM_reduced"><code>L_DBCM_reduced</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/DBCM.jl#L1208-L1226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{DBCM}" href="#Base.length-Tuple{DBCM}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the reduced number of nodes in the UBCM network</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/DBCM.jl#L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.L_DBCM_reduced" href="#MaxEntropyGraphs.L_DBCM_reduced"><code>MaxEntropyGraphs.L_DBCM_reduced</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">L_DBCM_reduced(θ::Vector, k_out::Vector, k_in::Vector, F::Vector, nz_out::Vector, nz_in::Vector, n::Int=length(k_out))</code></pre><p>Compute the log-likelihood of the reduced DBCM model using the exponential formulation in order to maintain convexity.</p><p><strong>Arguments</strong></p><pre><code class="nohighlight hljs">- `θ`: the maximum likelihood parameters of the model ([α; β])
- `k_out`: the reduced outdegree sequence
- `k_in`: the reduced indegree sequence
- `F`: the frequency of each pair in the degree sequence
- `nz_out`: the indices of non-zero elements in the reduced outdegree sequence
- `nz_in`: the indices of non-zero elements in the reduced indegree sequence
- `n`: the number of nodes in the reduced model</code></pre><p>The function returns the log-likelihood of the reduced model. For the optimisation, this function will be used to generate an anonymous function associated with a specific model.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># Generic use:
julia&gt; k_out  = [1, 1, 1, 2, 2, 2, 3, 3, 4, 4, 4, 5, 5];

julia&gt; k_in   = [2, 3, 4, 1, 3, 5, 2, 4, 1, 2, 4, 0, 4];

julia&gt; F      = [2, 2, 1, 1, 1, 2, 3, 1, 1, 2, 2, 1, 1];

julia&gt; θ      = collect(range(0.1, step=0.1, length=length(k_out)));

julia&gt; nz_out = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];

julia&gt; nz_in  = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13];

julia&gt; n      = length(k_out);

julia&gt; L_DBCM_reduced(θ, k_out, k_in, F, nz_out, nz_in, n)
-2.2036983875623528e244</code></pre><pre><code class="language-julia-repl hljs"># Use with DBCM model:
julia&gt; G = MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques());

julia&gt; model = DBCM(G);

julia&gt; model_fun = θ -&gt; L_DBCM_reduced(θ, model.dᵣ_out, model.dᵣ_in, model.f, model.dᵣ_out_nz, model.dᵣ_in_nz, model.status[:d_unique]);

julia&gt; model_fun(ones(size(model.θᵣ)))
-252.4627226503138</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/DBCM.jl#L156-L204">source</a></section><section><div><pre><code class="nohighlight hljs">L_DBCM_reduced(m::DBCM)</code></pre><p>Return the log-likelihood of the DBCM model <code>m</code> based on the computed maximum likelihood parameters.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># Use with DBCM model:
julia&gt; G = MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques());

julia&gt; model = DBCM(G);

julia&gt; solve_model!(model);

julia&gt; L_DBCM_reduced(model)
-120.15942408828172</code></pre><p>See also <a href="#MaxEntropyGraphs.L_DBCM_reduced"><code>L_DBCM_reduced(::Vector, ::Vector, ::Vector, ::Vector, ::Vector, ::Vector)</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/DBCM.jl#L228-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.∇L_DBCM_reduced!" href="#MaxEntropyGraphs.∇L_DBCM_reduced!"><code>MaxEntropyGraphs.∇L_DBCM_reduced!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">∇L_DBCM_reduced!(∇L::AbstractVector, θ::AbstractVector, k_out::AbstractVector, k_in::AbstractVector, F::AbstractVector, nz_out::Vector, nz_in::Vector, x::AbstractVector, y::AbstractVector,n::Int)</code></pre><p>Compute the gradient of the log-likelihood of the reduced DBCM model using the exponential formulation in order to maintain convexity.</p><p>For the optimisation, this function will be used togenerate an anonymous function associated with a specific model. The function  will update pre-allocated vectors (<code>∇L</code>,<code>x</code> and <code>y</code>) for speed. The gradient is non-allocating.</p><p><strong>Arguments</strong></p><ul><li><code>∇L</code>: the gradient of the log-likelihood of the reduced model</li><li><code>θ</code>: the maximum likelihood parameters of the model ([α; β])</li><li><code>k_out</code>: the reduced outdegree sequence</li><li><code>k_in</code>: the reduced indegree sequence</li><li><code>F</code>: the frequency of each pair in the degree sequence</li><li><code>nz_out</code>: the indices of non-zero elements in the reduced outdegree sequence</li><li><code>nz_in</code>: the indices of non-zero elements in the reduced indegree sequence</li><li><code>x</code>: the exponentiated maximum likelihood parameters of the model ( xᵢ = exp(-αᵢ) )</li><li><code>y</code>: the exponentiated maximum likelihood parameters of the model ( yᵢ = exp(-βᵢ) )</li><li><code>n</code>: the number of nodes in the reduced model</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># Explicit use with DBCM model:
julia&gt; G = MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques());

julia&gt; model = DBCM(G);

julia&gt; ∇L = zeros(Real, length(model.θᵣ));

julia&gt; x  = zeros(Real, length(model.xᵣ));

julia&gt; y  = zeros(Real, length(model.yᵣ));

julia&gt; ∇model_fun! = θ -&gt; ∇L_DBCM_reduced!(∇L, θ, model.dᵣ_out, model.dᵣ_in, model.f, model.dᵣ_out_nz, model.dᵣ_in_nz, x, y, model.status[:d_unique]);

julia&gt; ∇model_fun!(model.θᵣ);
</code></pre><pre><code class="language-julia-repl hljs"># Use within optimisation.jl framework:
julia&gt; fun = (θ,p) -&gt; -L_DBCM_reduced(θ, model.dᵣ_out, model.dᵣ_in, model.f, model.dᵣ_out_nz, model.dᵣ_in_nz, model.status[:d_unique]);

julia&gt; x  = zeros(Real, length(model.xᵣ)); # initialise  buffer

julia&gt; y  = zeros(Real, length(model.yᵣ));#  initialise  buffer

julia&gt; ∇fun! = (∇L, θ, p) -&gt; ∇L_DBCM_reduced!(∇L, θ, model.dᵣ_out, model.dᵣ_in, model.f, model.dᵣ_out_nz, model.dᵣ_in_nz, x, y, model.status[:d_unique]);

julia&gt; θ₀ = initial_guess(model); # initial condition

julia&gt; foo = MaxEntropyGraphs.Optimization.OptimizationFunction(fun, grad=∇fun!); # define target function 

julia&gt; prob  = MaxEntropyGraphs.Optimization.OptimizationProblem(foo, θ₀); # define the optimisation problem

julia&gt; method = MaxEntropyGraphs.OptimizationOptimJL.LBFGS(); # set the optimisation method

julia&gt; MaxEntropyGraphs.Optimization.solve(prob, method); # solve it
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/DBCM.jl#L257-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.∇L_DBCM_reduced_minus!" href="#MaxEntropyGraphs.∇L_DBCM_reduced_minus!"><code>MaxEntropyGraphs.∇L_DBCM_reduced_minus!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">∇L_DBCM_reduced_minus!(args...)</code></pre><p>Compute minus the gradient of the log-likelihood of the reduced DBCM model using the exponential formulation in order to maintain convexity. Used for optimisation in a non-allocating manner.</p><p>See also <a href="#MaxEntropyGraphs.∇L_DBCM_reduced!"><code>∇L_DBCM_reduced!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/DBCM.jl#L364-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.DBCM_reduced_iter!" href="#MaxEntropyGraphs.DBCM_reduced_iter!"><code>MaxEntropyGraphs.DBCM_reduced_iter!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">DBCM_reduced_iter!(θ::AbstractVector, k_out::AbstractVector, k_in::AbstractVector, F::AbstractVector, nz_out::Vector, nz_in::Vector,x::AbstractVector, y::AbstractVector, G::AbstractVector, H::AbstractVector, n::Int)</code></pre><p>Computer the next fixed-point iteration for the DBCM model using the exponential formulation in order to maintain convexity. The function is non-allocating and will update pre-allocated vectors (<code>θ</code>, <code>x</code>, <code>y</code> and <code>G</code>) for speed.</p><p><strong>Arguments</strong></p><ul><li><code>θ</code>: the maximum likelihood parameters of the model ([α; β])</li><li><code>k_out</code>: the reduced outdegree sequence</li><li><code>k_in</code>: the reduced indegree sequence</li><li><code>F</code>: the frequency of each pair in the degree sequence</li><li><code>nz_out</code>: the indices of non-zero elements in the reduced outdegree sequence</li><li><code>nz_in</code>: the indices of non-zero elements in the reduced indegree sequence</li><li><code>x</code>: the exponentiated maximum likelihood parameters of the model ( xᵢ = exp(-αᵢ) )</li><li><code>y</code>: the exponentiated maximum likelihood parameters of the model ( yᵢ = exp(-βᵢ) )</li><li><code>G</code>: buffer for computations</li><li><code>n</code>: the number of nodes in the reduced model</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># Use with DBCM model:
julia&gt; G = MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques());

julia&gt; model = DBCM(G);

julia&gt; G = zeros(eltype(model.θᵣ), length(model.θᵣ));

julia&gt; H = zeros(eltype(model.θᵣ), length(model.yᵣ));

julia&gt; x = zeros(eltype(model.θᵣ), length(model.xᵣ));

julia&gt; y = zeros(eltype(model.θᵣ), length(model.yᵣ));

julia&gt; DBCM_FP! = θ -&gt; DBCM_reduced_iter!(θ, model.dᵣ_out, model.dᵣ_in, model.f, model.dᵣ_out_nz, model.dᵣ_in_nz, x, y, G, model.status[:d_unique]);

julia&gt; DBCM_FP!(model.θᵣ);
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/DBCM.jl#L418-L457">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.set_xᵣ!-Tuple{DBCM}" href="#MaxEntropyGraphs.set_xᵣ!-Tuple{DBCM}"><code>MaxEntropyGraphs.set_xᵣ!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_xᵣ!(m::DBCM)</code></pre><p>Set the value of xᵣ to exp(-αᵣ) for the DBCM model <code>m</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/DBCM.jl#L552-L556">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.set_yᵣ!-Tuple{DBCM}" href="#MaxEntropyGraphs.set_yᵣ!-Tuple{DBCM}"><code>MaxEntropyGraphs.set_yᵣ!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_yᵣ!(m::DBCM)</code></pre><p>Set the value of yᵣ to exp(-βᵣ) for the DBCM model <code>m</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/DBCM.jl#L566-L570">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.Ĝ-Tuple{DBCM}" href="#MaxEntropyGraphs.Ĝ-Tuple{DBCM}"><code>MaxEntropyGraphs.Ĝ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Ĝ(m::DBCM)</code></pre><p>Compute the expected adjacency matrix for the DBCM model <code>m</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/DBCM.jl#L581-L585">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.set_Ĝ!-Tuple{DBCM}" href="#MaxEntropyGraphs.set_Ĝ!-Tuple{DBCM}"><code>MaxEntropyGraphs.set_Ĝ!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_Ĝ!(m::DBCM)</code></pre><p>Set the expected adjacency matrix for the DBCM model <code>m</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/DBCM.jl#L611-L615">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.σˣ-Tuple{DBCM}" href="#MaxEntropyGraphs.σˣ-Tuple{DBCM}"><code>MaxEntropyGraphs.σˣ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">σˣ(m::DBCM{T,N}) where {T,N}</code></pre><p>Compute the standard deviation for the elements of the adjacency matrix for the DBCM model <code>m</code>.</p><p><strong>Note:</strong> read as &quot;sigma star&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/DBCM.jl#L623-L629">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.set_σ!-Tuple{DBCM}" href="#MaxEntropyGraphs.set_σ!-Tuple{DBCM}"><code>MaxEntropyGraphs.set_σ!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_σ!(m::DBCM)</code></pre><p>Set the standard deviation for the elements of the adjacency matrix for the DBCM model <code>m</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/DBCM.jl#L653-L657">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.precision-Tuple{DBCM}" href="#Base.precision-Tuple{DBCM}"><code>Base.precision</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">precision(m::DBCM)</code></pre><p>Determine the compute precision of the UBCM model <code>m</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = DBCM(MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques()));

julia&gt; MaxEntropyGraphs.precision(model)
Float64</code></pre><pre><code class="language-julia-repl hljs">julia&gt; model = DBCM(MaxEntropyGraphs.Graphs.SimpleDiGraph(rhesus_macaques()), precision=Float32);

julia&gt; MaxEntropyGraphs.precision(model)
Float32</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/DBCM.jl#L860-L879">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.A-Tuple{DBCM, Int64, Int64}" href="#MaxEntropyGraphs.A-Tuple{DBCM, Int64, Int64}"><code>MaxEntropyGraphs.A</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">A(m::DBCM,i::Int,j::Int)</code></pre><p>Return the expected value of the adjacency matrix for the DBCM model <code>m</code> at the node pair <code>(i,j)</code>.</p><p>❗ For perfomance reasons, the function does not check:</p><ul><li>if the node pair is valid.</li><li>if the parameters of the model have been computed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/DBCM.jl#L892-L900">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.f_DBCM-Tuple{DBCM}" href="#MaxEntropyGraphs.f_DBCM-Tuple{DBCM}"><code>MaxEntropyGraphs.f_DBCM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">f_DBCM(x::T)</code></pre><p>Helper function for the DBCM model to compute the expected value of the adjacency matrix. The function computes the expression <code>x / (1 + x)</code>. As an argument you need to pass the product of the maximum likelihood parameters <code>xᵣ[i] * yᵣ[j]</code> from a DBCM model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/DBCM.jl#L883-L888">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntropyGraphs.σₓ-Tuple{DBCM, Function}" href="#MaxEntropyGraphs.σₓ-Tuple{DBCM, Function}"><code>MaxEntropyGraphs.σₓ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">σₓ(m::DBCM, X::function)</code></pre><p>Compute the standard deviation of metric <code>X</code> for the DBCM model <code>m</code>. </p><p>This requires that both the expected values (m.Ĝ) and standard deviations (m.σ) are computed for <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/44c852fa2a41f8c3f32df0b4d75b5e8f7df3adfd/src/Models/DBCM.jl#L1241-L1247">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../GPU/">« GPU acceleration</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 29 September 2023 14:12">Friday 29 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
