<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>BiCM · MaxEntropyGraphs.jl</title><meta name="title" content="BiCM · MaxEntropyGraphs.jl"/><meta property="og:title" content="BiCM · MaxEntropyGraphs.jl"/><meta property="twitter:title" content="BiCM · MaxEntropyGraphs.jl"/><meta name="description" content="Documentation for MaxEntropyGraphs.jl."/><meta property="og:description" content="Documentation for MaxEntropyGraphs.jl."/><meta property="twitter:description" content="Documentation for MaxEntropyGraphs.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.jpeg" alt="MaxEntropyGraphs.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MaxEntropyGraphs.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Models</span><ul><li><a class="tocitem" href="../../models/">Overview</a></li><li><a class="tocitem" href="../../models/UBCM/">UBCM</a></li><li><a class="tocitem" href="../../models/DBCM/">DBCM</a></li><li><a class="tocitem" href="../../models/BiCM/">BiCM</a></li></ul></li><li><span class="tocitem">Metrics</span><ul><li><a class="tocitem" href="../../metrics/">Overview</a></li><li><a class="tocitem" href="../../exact/">Analytical</a></li><li><a class="tocitem" href="../../simulated/">Simulation</a></li></ul></li><li><a class="tocitem" href="../../GPU/">GPU acceleration</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../API/">Shared</a></li><li><a class="tocitem" href="../API_UBCM/">UBCM</a></li><li><a class="tocitem" href="../API_DBCM/">DBCM</a></li><li class="is-active"><a class="tocitem" href>BiCM</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>BiCM</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>BiCM</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/main/docs/src/API/API_BiCM.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#MaxEntropyGraphs.BiCM-Tuple{T} where T"><code>MaxEntropyGraphs.BiCM</code></a></li><li><a href="#MaxEntropyGraphs.BiCM"><code>MaxEntropyGraphs.BiCM</code></a></li><li><a href="#Base.length-Tuple{BiCM}"><code>Base.length</code></a></li><li><a href="#Base.precision-Tuple{BiCM}"><code>Base.precision</code></a></li><li><a href="#Base.rand-Tuple{BiCM, Int64}"><code>Base.rand</code></a></li><li><a href="#Base.rand-Tuple{BiCM}"><code>Base.rand</code></a></li><li><a href="#MaxEntropyGraphs.A-Tuple{BiCM, Int64, Int64}"><code>MaxEntropyGraphs.A</code></a></li><li><a href="#MaxEntropyGraphs.AIC-Tuple{BiCM}"><code>MaxEntropyGraphs.AIC</code></a></li><li><a href="#MaxEntropyGraphs.AICc-Tuple{BiCM}"><code>MaxEntropyGraphs.AICc</code></a></li><li><a href="#MaxEntropyGraphs.BIC-Tuple{BiCM}"><code>MaxEntropyGraphs.BIC</code></a></li><li><a href="#MaxEntropyGraphs.BiCM_reduced_iter!"><code>MaxEntropyGraphs.BiCM_reduced_iter!</code></a></li><li><a href="#MaxEntropyGraphs.L_BiCM_reduced"><code>MaxEntropyGraphs.L_BiCM_reduced</code></a></li><li><a href="#MaxEntropyGraphs.biadjacency_matrix"><code>MaxEntropyGraphs.biadjacency_matrix</code></a></li><li><a href="#MaxEntropyGraphs.f_BiCM-Tuple{BiCM}"><code>MaxEntropyGraphs.f_BiCM</code></a></li><li><a href="#MaxEntropyGraphs.initial_guess-Tuple{BiCM}"><code>MaxEntropyGraphs.initial_guess</code></a></li><li><a href="#MaxEntropyGraphs.project"><code>MaxEntropyGraphs.project</code></a></li><li><a href="#MaxEntropyGraphs.set_xᵣ!-Tuple{BiCM}"><code>MaxEntropyGraphs.set_xᵣ!</code></a></li><li><a href="#MaxEntropyGraphs.set_yᵣ!-Tuple{BiCM}"><code>MaxEntropyGraphs.set_yᵣ!</code></a></li><li><a href="#MaxEntropyGraphs.set_Ĝ!-Tuple{BiCM}"><code>MaxEntropyGraphs.set_Ĝ!</code></a></li><li><a href="#MaxEntropyGraphs.solve_model!-Tuple{BiCM}"><code>MaxEntropyGraphs.solve_model!</code></a></li><li><a href="#MaxEntropyGraphs.Ĝ-Tuple{BiCM}"><code>MaxEntropyGraphs.Ĝ</code></a></li><li><a href="#MaxEntropyGraphs.∇L_BiCM_reduced!"><code>MaxEntropyGraphs.∇L_BiCM_reduced!</code></a></li><li><a href="#MaxEntropyGraphs.∇L_BiCM_reduced_minus!"><code>MaxEntropyGraphs.∇L_BiCM_reduced_minus!</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.BiCM" href="#MaxEntropyGraphs.BiCM"><code>MaxEntropyGraphs.BiCM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BiCM</code></pre><p>Maximum entropy model for the Undirected Bipartite Configuration Model (BiCM). </p><p>The object holds the maximum likelihood parameters of the model (θ), the expected bi-adjacency matrix (Ĝ),  and the variance for the elements of the adjacency matrix (σ).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/f6ec80b8a47fdf63a799e4661aa808852612f818/src/Models/BiCM.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.BiCM-Tuple{T} where T" href="#MaxEntropyGraphs.BiCM-Tuple{T} where T"><code>MaxEntropyGraphs.BiCM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BiCM(G::T; precision::N=Float64, kwargs...) where {T&lt;:Graphs.AbstractGraph, N&lt;:Real}
BiCM(;d⊥::Vector{T}, d⊤::Vector{T}, precision::Type{&lt;:AbstractFloat}=Float64, kwargs...)</code></pre><p>Constructor function for the <code>BiCM</code> type. The graph you provide should be bipartite</p><p>By default and dependng on the graph type <code>T</code>, the definition of degree from <span>$Graphs.jl$</span> is applied.  If you want to use a different definition of degrees, you can pass vectors of degrees sequences as keyword arguments (<code>d⊥</code>, <code>d⊤</code>). If you want to generate a model directly from degree sequences without an underlying graph , you can simply pass the degree sequences as arguments (<code>d⊥</code>, <code>d⊤</code>). If you want to work from an adjacency matrix, or edge list, you can use the graph constructors from the <span>$JuliaGraphs$</span> ecosystem.</p><p>Zero degree nodes have a zero probability of being connected to other nodes, so they are skipped in the computation of the model.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># generating a model from a graph
julia&gt; G = corporateclub();

julia&gt; model =  BiCM(G)
BiCM{Graphs.SimpleGraphs.SimpleGraph{Int64}, Float64} (25 + 15 vertices, 6 + 6 unique degrees, 0.30 compression ratio)
</code></pre><pre><code class="language-julia-repl hljs"># generating a model directly from a degree sequence
julia&gt; model = model = BiCM(d⊥=[1,1,2,2,2,3,3,1,1,2], d⊤=[3,4,5,2,5,6,6,1,1,2])
BiCM{Nothing, Float64} (10 + 10 vertices, 3 + 6 unique degrees, 0.45 compression ratio)
</code></pre><pre><code class="language-julia-repl hljs"># generating a model directly from a degree sequence with a different precision
julia&gt; model = model = BiCM(d⊥=[1,1,2,2,2,3,3,1,1,2], d⊤=[3,4,5,2,5,6,6,1,1,2], precision=Float32)
BiCM{Nothing, Float32} (10 + 10 vertices, 3 + 6 unique degrees, 0.45 compression ratio)
</code></pre><pre><code class="language-julia-repl hljs"># generating a model from an adjacency matrix
julia&gt; A = [0 0 0 1 0;0 0 0 1 0;0 0 0 0 1;1 1 0 0 0;0 0 1 0 0];

julia&gt; G = MaxEntropyGraphs.Graphs.SimpleGraph(A);

julia&gt; @assert MaxEntropyGraphs.Graphs.is_bipartite(G); # check if the graph is bipartite

julia&gt; model = BiCM(G) # generating the model
BiCM{Graphs.SimpleGraphs.SimpleGraph{Int64}, Float64} (3 + 2 vertices, 1 + 2 unique degrees, 0.60 compression ratio)
</code></pre><pre><code class="language-julia-repl hljs"># generating a model from a biadjacency matrix
julia&gt; biadjacency = [1 0;1 0; 0 1];

julia&gt; N⊥,N⊤ = size(biadjacency); # layer dimensions

julia&gt; adjacency = [zeros(Int, N⊥,N⊥) biadjacency; biadjacency&#39; zeros(Int,N⊤,N⊤)];

julia&gt; G = MaxEntropyGraphs.Graphs.SimpleGraph(adjacency); # generate graph

julia&gt; model = BiCM(G) # generate model
BiCM{Graphs.SimpleGraphs.SimpleGraph{Int64}, Float64} (3 + 2 vertices, 1 + 2 unique degrees, 0.60 compression ratio)
</code></pre><pre><code class="language-julia-repl hljs"># generating a model from an edge list
julia&gt; edges = MaxEntropyGraphs.Graphs.SimpleEdge.([(1,4); (2,4); (3,5)]);

julia&gt; G = MaxEntropyGraphs.Graphs.SimpleGraph(edges); # generate graph

julia&gt; model = BiCM(G) # generate model
BiCM{Graphs.SimpleGraphs.SimpleGraph{Int64}, Float64} (3 + 2 vertices, 1 + 2 unique degrees, 0.60 compression ratio)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/f6ec80b8a47fdf63a799e4661aa808852612f818/src/Models/BiCM.jl#L69-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.solve_model!-Tuple{BiCM}" href="#MaxEntropyGraphs.solve_model!-Tuple{BiCM}"><code>MaxEntropyGraphs.solve_model!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve_model!(m::BiCM)</code></pre><p>Compute the likelihood maximising parameters of the BiCM model <code>m</code>. </p><p><strong>Arguments</strong></p><ul><li><code>method::Symbol</code>: solution method to use, can be <code>:fixedpoint</code> (default), or :NelderMead, :BFGS, :LBFGS and :Newton.</li><li><code>initial::Symbol</code>: initial guess for the parameters <span>$\Theta$</span>, can be :degrees (default), :random, :uniform, or :chung_lu.</li><li><code>maxiters::Int</code>: maximum number of iterations for the solver (defaults to 1000). </li><li><code>verbose::Bool</code>: set to show log messages (defaults to false).</li><li><code>ftol::Real</code>: function tolerance for convergence with the fixedpoint method (defaults to 1e-8).</li><li><code>abstol::Union{Number, Nothing}</code>: absolute function tolerance for convergence with the other methods (defaults to <code>nothing</code>).</li><li><code>reltol::Union{Number, Nothing}</code>: relative function tolerance for convergence with the other methods (defaults to <code>nothing</code>).</li><li><code>AD_method::Symbol</code>: autodiff method to use, can be any of :AutoZygote, :AutoReverseDiff, :AutoForwardDiff and :AutoFiniteDiff. Performance depends on the size of the problem (defaults to <code>:AutoZygote</code>),</li><li><code>analytical_gradient::Bool</code>: set the use the analytical gradient instead of the one generated with autodiff (defaults to <code>false</code>)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># default use
julia&gt; model = BiCM(corporateclub());

julia&gt; solve_model!(model);
</code></pre><pre><code class="language-julia-repl hljs"># using analytical gradient and uniform initial guess
julia&gt; solve_model!(model, method=:BFGS, analytical_gradient=true, initial=:uniform)
(BiCM{Graphs.SimpleGraphs.SimpleGraph{Int64}, Float64} (25 + 15 vertices, 6 + 6 unique degrees, 0.30 compression ratio), retcode: Success
u: [1.449571644621672, 0.8231752829683303, 0.34755085972479766, -0.04834480708852856, -0.3984299800917503, -0.7223268299919358, 1.6090554004279671, 1.2614196476197532, 0.9762560461922147, 0.11406188481061938, -0.24499004480426345, -2.2646067641037333]
Final objective value:     171.15095803718134
)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/f6ec80b8a47fdf63a799e4661aa808852612f818/src/Models/BiCM.jl#L702-L735">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.initial_guess-Tuple{BiCM}" href="#MaxEntropyGraphs.initial_guess-Tuple{BiCM}"><code>MaxEntropyGraphs.initial_guess</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_guess(m::BiCM; method::Symbol=:degrees)</code></pre><p>Compute an initial guess for the maximum likelihood parameters of the BiCM model <code>m</code> using the method <code>method</code>.</p><p>The methods available are: </p><ul><li><code>:degrees</code> (default): the initial guess is computed using the degrees of the graph, i.e. <span>$\theta = [-\log(d_{ot}); -\log(d_{	op})]$</span> </li><li><code>:random</code>: the initial guess is computed using random values between 0 and 1, i.e. <span>$\theta_{i} = -\log(r_{i})$</span> where <span>$r_{i} \sim U(0,1)$</span></li><li><code>:uniform</code>: the initial guess is uniformily set to 0.5, i.e. <span>$\theta_{i} = -\log(0.5)$</span></li><li><code>:chung_lu</code>: the initial guess is computed using the degrees of the graph and the number of edges, i.e. <span>$\theta = [-\log(d_{ot}/(2E)); -\log(d_{	op}/(2E))]$</span></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = BiCM(corporateclub());

julia&gt; initial_guess(model, method=:random);

julia&gt; initial_guess(model, method=:uniform);

julia&gt; initial_guess(model, method=:chung_lu);

julia&gt; initial_guess(model);
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/f6ec80b8a47fdf63a799e4661aa808852612f818/src/Models/BiCM.jl#L530-L554">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rand-Tuple{BiCM}" href="#Base.rand-Tuple{BiCM}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand(m::BiCM; precomputed::Bool=false)</code></pre><p>Generate a random graph from the BiCM model <code>m</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>precomputed::Bool</code>: if <code>true</code>, the precomputed expected <strong>biadjacency matrix</strong> (<code>m.Ĝ</code>) is used to generate the random graph, otherwise the maximum likelihood parameters are used to generate the random graph on the fly. For larger networks, it is  recommended to not precompute the expected adjacency matrix to limit memory pressure.</li></ul><p><strong>Note</strong>: The generated graph will also be bipartite and respect the layer membership of the original graph used to define the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/f6ec80b8a47fdf63a799e4661aa808852612f818/src/Models/BiCM.jl#L645-L655">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rand-Tuple{BiCM, Int64}" href="#Base.rand-Tuple{BiCM, Int64}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand(m::BiCM, n::Int; precomputed::Bool=false)

Generate `n` random graphs from the BiCM model `m`. If multithreading is available, the graphs are generated in parallel.</code></pre><p><strong>Arguments:</strong></p><ul><li><code>precomputed::Bool</code>: if <code>true</code>, the precomputed expected <strong>biadjacency matrix</strong> (<code>m.Ĝ</code>) is used to generate the random graph, otherwise the maximum likelihood parameters are used to generate the random graph on the fly. For larger networks, it is  recommended to not precompute the expected adjacency matrix to limit memory pressure.</li></ul><p><strong>Note</strong>: The generated graph will also be bipartite and respect the layer membership of the original graph used to define the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/f6ec80b8a47fdf63a799e4661aa808852612f818/src/Models/BiCM.jl#L680-L690">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.AIC-Tuple{BiCM}" href="#MaxEntropyGraphs.AIC-Tuple{BiCM}"><code>MaxEntropyGraphs.AIC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AIC(m::BiCM)</code></pre><p>Compute the Akaike Information Criterion (AIC) for the BiCM model <code>m</code>. The parameters of the models most be computed beforehand.  If the number of empirical observations becomes too small with respect to the number of parameters, you will get a warning. In  that case, the corrected AIC (AICc) should be used instead.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; model = BiCM(corporateclub());

julia&gt; solve_model!(model);

julia&gt; AIC(model);
[...]
</code></pre><p>See also <a href="#MaxEntropyGraphs.AICc-Tuple{BiCM}"><code>AICc</code></a>, <a href="#MaxEntropyGraphs.L_BiCM_reduced"><code>L_BiCM_reduced</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/f6ec80b8a47fdf63a799e4661aa808852612f818/src/Models/BiCM.jl#L932-L951">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.AICc-Tuple{BiCM}" href="#MaxEntropyGraphs.AICc-Tuple{BiCM}"><code>MaxEntropyGraphs.AICc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AICc(m::BiCM)</code></pre><p>Compute the corrected Akaike Information Criterion (AICc) for the BiCM model <code>m</code>. The parameters of the models most be computed beforehand. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = BiCM(corporateclub());

julia&gt; solve_model!(model);

julia&gt; AICc(model)
432.12227535579956
</code></pre><p>See also <a href="#MaxEntropyGraphs.AIC-Tuple{BiCM}"><code>AIC</code></a>, <a href="#MaxEntropyGraphs.L_BiCM_reduced"><code>L_BiCM_reduced</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/f6ec80b8a47fdf63a799e4661aa808852612f818/src/Models/BiCM.jl#L968-L986">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.BIC-Tuple{BiCM}" href="#MaxEntropyGraphs.BIC-Tuple{BiCM}"><code>MaxEntropyGraphs.BIC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BIC(m::BiCM)</code></pre><p>Compute the Bayesian Information Criterion (BIC) for the BiCM model <code>m</code>. The parameters of the models most be computed beforehand.  BIC is believed to be more restrictive than AIC, as the former favors models with a lower number of parameters than those favored by the latter.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = BiCM(corporateclub());

julia&gt; solve_model!(model);

julia&gt; BIC(model)
579.3789571131789
</code></pre><p>See also <a href="#MaxEntropyGraphs.AIC-Tuple{BiCM}"><code>AIC</code></a>, <a href="#MaxEntropyGraphs.L_BiCM_reduced"><code>L_BiCM_reduced</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/f6ec80b8a47fdf63a799e4661aa808852612f818/src/Models/BiCM.jl#L999-L1017">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.length-Tuple{BiCM}" href="#Base.length-Tuple{BiCM}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the reduced number of nodes in the UBCM network</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/f6ec80b8a47fdf63a799e4661aa808852612f818/src/Models/BiCM.jl#L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.L_BiCM_reduced" href="#MaxEntropyGraphs.L_BiCM_reduced"><code>MaxEntropyGraphs.L_BiCM_reduced</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">L_BiCM_reduced(θ::Vector, k⊥::Vector, k⊤::Vector, f⊥::Vector, f⊤::Vector, nz⊥::UnitRange, nz⊤::UnitRange, n⊥ᵣ::Int)</code></pre><p>Compute the log-likelihood of the reduced BiCM model using the exponential formulation in order to maintain convexity.</p><p><strong>Arguments</strong></p><ul><li><code>θ</code>: the maximum likelihood parameters of the model ([α; β])</li><li><code>k⊥</code>: the reduced degree sequence of the ⊥ layer</li><li><code>k⊤</code>: the reduced degree sequence of the ⊤ layer</li><li><code>f⊥</code>: the frequency of each degree in the ⊥ layer</li><li><code>f⊤</code>: the frequency of each degree in the ⊤ layer</li><li><code>nz⊥</code>: the indices of non-zero elements in the reduced ⊥ layer degree sequence</li><li><code>nz⊤</code>: the indices of non-zero elements in the reduced ⊤ layer degree sequence</li><li><code>n⊥ᵣ</code>: the number unique values in the reduced ⊥ layer degree sequence</li></ul><p>The function returns the log-likelihood of the reduced model. For the optimisation, this function will be used to generate an anonymous function associated with a specific model.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># Generic use:
julia&gt; k⊥ = [1, 2, 3, 4];

julia&gt; k⊤  = [1, 2, 4];

julia&gt; f⊥  = [1; 3; 1; 1];

julia&gt; f⊤  = [4; 2; 1];

julia&gt; nz⊥ = 1:length(k⊥);

julia&gt; nz⊤ = 1:length(k⊤);

julia&gt; n⊥ᵣ = length(k⊥);

julia&gt; θ   = collect(range(0.1, step=0.1, length=length(k⊥) + length(k⊤)));

julia&gt; L_BiCM_reduced(θ, k⊥, k⊤, f⊥, f⊤, nz⊥, nz⊤, n⊥ᵣ)
-26.7741690720244</code></pre><pre><code class="language-julia-repl hljs"># Use with DBCM model:
julia&gt; G = corporateclub();

julia&gt; model = BiCM(G);

julia&gt; model_fun = θ -&gt; L_BiCM_reduced(θ, model.d⊥ᵣ, model.d⊤ᵣ, model.f⊥, model.f⊤, model.d⊥ᵣ_nz, model.d⊤ᵣ_nz, model.status[:d⊥_unique]);

julia&gt; model_fun(ones(size(model.θᵣ)))
-237.5980041411147</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/f6ec80b8a47fdf63a799e4661aa808852612f818/src/Models/BiCM.jl#L215-L267">source</a></section><section><div><pre><code class="language-julia hljs">L_BiCM_reduced(m::BiCM)</code></pre><p>Return the log-likelihood of the BiCM model <code>m</code> based on the computed maximum likelihood parameters.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># Use with DBCM model:
julia&gt; G = corporateclub();

julia&gt; model = BiCM(G);

julia&gt; solve_model!(model);

julia&gt; L_BiCM_reduced(model);
</code></pre><p>See also <a href="#MaxEntropyGraphs.L_BiCM_reduced"><code>L_BiCM_reduced(::Vector, ::Vector, ::Vector, ::Vector, ::Vector, ::UnitRange, ::UnitRange, ::Int)</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/f6ec80b8a47fdf63a799e4661aa808852612f818/src/Models/BiCM.jl#L287-L306">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.∇L_BiCM_reduced!" href="#MaxEntropyGraphs.∇L_BiCM_reduced!"><code>MaxEntropyGraphs.∇L_BiCM_reduced!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">∇L_BiCM_reduced!(∇L::AbstractVector, θ::AbstractVector, k⊥::Vector, k⊤::Vector, f⊥::Vector, f⊤::Vector,  nz⊥::UnitRange{T}, nz⊤::UnitRange{T}, x::AbstractVector, y::AbstractVector, n⊥::Int) where {T&lt;:Signed}</code></pre><p>Compute the gradient of the log-likelihood of the reduced DBCM model using the exponential formulation in order to maintain convexity.</p><p>For the optimisation, this function will be used togenerate an anonymous function associated with a specific model. The function  will update pre-allocated vectors (<code>∇L</code>,<code>x</code> and <code>y</code>) for speed. The gradient is non-allocating.</p><p><strong>Arguments</strong></p><ul><li><code>∇L</code>: the gradient of the log-likelihood of the reduced model</li><li><code>θ</code>: the maximum likelihood parameters of the model ([α; β])</li><li><code>k⊥</code>: the reduced degree sequence of the ⊥ layer</li><li><code>k⊤</code>: the reduced degree sequence of the ⊤ layer</li><li><code>f⊥</code>: the frequency of each degree in the ⊥ layer</li><li><code>f⊤</code>: the frequency of each degree in the ⊤ layer</li><li><code>nz⊥</code>: the indices of non-zero elements in the reduced ⊥ layer degree sequence</li><li><code>nz⊤</code>: the indices of non-zero elements in the reduced ⊤ layer degree sequence</li><li><code>x</code>: the exponentiated maximum likelihood parameters of the model ( xᵢ = exp(-αᵢ) )</li><li><code>y</code>: the exponentiated maximum likelihood parameters of the model ( yᵢ = exp(-βᵢ) )</li><li><code>n⊥</code>: the number unique values in the reduced ⊥ layer degree sequence</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># Explicit use with BiCM model:
julia&gt; G = corporateclub();

julia&gt; model = BiCM(G);

julia&gt; ∇L = zeros(Real, length(model.θᵣ));

julia&gt; x  = zeros(Real, length(model.xᵣ));

julia&gt; y  = zeros(Real, length(model.yᵣ));

julia&gt; ∇model_fun! = θ -&gt; ∇L_BiCM_reduced!(∇L, θ, model.d⊥ᵣ, model.d⊤ᵣ, model.f⊥, model.f⊤, model.d⊥ᵣ_nz, model.d⊤ᵣ_nz, x, y, model.status[:d⊥_unique]);

julia&gt; ∇model_fun!(model.θᵣ);
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/f6ec80b8a47fdf63a799e4661aa808852612f818/src/Models/BiCM.jl#L310-L349">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.∇L_BiCM_reduced_minus!" href="#MaxEntropyGraphs.∇L_BiCM_reduced_minus!"><code>MaxEntropyGraphs.∇L_BiCM_reduced_minus!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">∇L_BiCM_reduced_minus!(args...)</code></pre><p>Compute minus the gradient of the log-likelihood of the reduced BiCM model using the exponential formulation in order to maintain convexity. Used for optimisation in a non-allocating manner.</p><p>See also <a href="#MaxEntropyGraphs.∇L_BiCM_reduced!"><code>∇L_BiCM_reduced!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/f6ec80b8a47fdf63a799e4661aa808852612f818/src/Models/BiCM.jl#L388-L394">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.BiCM_reduced_iter!" href="#MaxEntropyGraphs.BiCM_reduced_iter!"><code>MaxEntropyGraphs.BiCM_reduced_iter!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">BiCM_reduced_iter!(θ::AbstractVector, k⊥::Vector, k⊤::Vector, f⊥::Vector, f⊤::Vector, nz⊥::UnitRange{T}, nz⊤::UnitRange{T}, x::AbstractVector, y::AbstractVector, G::AbstractVector, n⊥::Int) where {T&lt;:Signed}</code></pre><p>Compute the next fixed-point iteration for the BiCM model using the exponential formulation in order to maintain convexity. The function is non-allocating and will update pre-allocated vectors (<code>θ</code>, <code>x</code>, <code>y</code> and <code>G</code>) for speed.</p><p><strong>Arguments</strong></p><ul><li><code>θ</code>: the maximum likelihood parameters of the model ([α; β])</li><li><code>k⊥</code>: the reduced degree sequence of the ⊥ layer</li><li><code>k⊤</code>: the reduced degree sequence of the ⊤ layer</li><li><code>f⊥</code>: the frequency of each degree in the ⊥ layer</li><li><code>f⊤</code>: the frequency of each degree in the ⊤ layer</li><li><code>nz⊥</code>: the indices of non-zero elements in the reduced ⊥ layer degree sequence</li><li><code>nz⊤</code>: the indices of non-zero elements in the reduced ⊤ layer degree sequence</li><li><code>x</code>: the exponentiated maximum likelihood parameters of the model ( xᵢ = exp(-αᵢ) )</li><li><code>y</code>: the exponentiated maximum likelihood parameters of the model ( yᵢ = exp(-βᵢ) )</li><li><code>G</code>: buffer for computations</li><li><code>n⊥</code>: the number unique values in the reduced ⊥ layer degree sequence</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># Use with BiCM model:
julia&gt; G = corporateclub();

julia&gt; model = BiCM(G);

julia&gt; G = zeros(eltype(model.θᵣ), length(model.θᵣ));

julia&gt; x = zeros(eltype(model.θᵣ), length(model.xᵣ));

julia&gt; y = zeros(eltype(model.θᵣ), length(model.yᵣ));


julia&gt; BiCM_FP! = θ -&gt; BiCM_reduced_iter!(θ, model.d⊥ᵣ, model.d⊤ᵣ, model.f⊥, model.f⊤, model.d⊥ᵣ_nz, model.d⊤ᵣ_nz, x, y, G, model.status[:d⊥_unique]);

julia&gt; BiCM_FP!(model.θᵣ);
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/f6ec80b8a47fdf63a799e4661aa808852612f818/src/Models/BiCM.jl#L432-L471">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.set_xᵣ!-Tuple{BiCM}" href="#MaxEntropyGraphs.set_xᵣ!-Tuple{BiCM}"><code>MaxEntropyGraphs.set_xᵣ!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_xᵣ!(m::BiCM)</code></pre><p>Set the value of xᵣ to exp(-αᵣ) for the BiCM model <code>m</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/f6ec80b8a47fdf63a799e4661aa808852612f818/src/Models/BiCM.jl#L571-L575">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.set_yᵣ!-Tuple{BiCM}" href="#MaxEntropyGraphs.set_yᵣ!-Tuple{BiCM}"><code>MaxEntropyGraphs.set_yᵣ!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_yᵣ!(m::BiCM)</code></pre><p>Set the value of yᵣ to exp(-βᵣ) for the BiCM model <code>m</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/f6ec80b8a47fdf63a799e4661aa808852612f818/src/Models/BiCM.jl#L586-L590">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.Ĝ-Tuple{BiCM}" href="#MaxEntropyGraphs.Ĝ-Tuple{BiCM}"><code>MaxEntropyGraphs.Ĝ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Ĝ(m::BiCM)</code></pre><p>Compute the expected <strong>biadjacency matrix</strong> for the BiCM model <code>m</code></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Please note that this generates a bi-adjacency matrix, not an adjacency matrix.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/f6ec80b8a47fdf63a799e4661aa808852612f818/src/Models/BiCM.jl#L601-L608">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.set_Ĝ!-Tuple{BiCM}" href="#MaxEntropyGraphs.set_Ĝ!-Tuple{BiCM}"><code>MaxEntropyGraphs.set_Ĝ!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_Ĝ!(m::BiCM)</code></pre><p>Set the expected <strong>biadjacency matrix</strong> for the BiCM model <code>m</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/f6ec80b8a47fdf63a799e4661aa808852612f818/src/Models/BiCM.jl#L634-L638">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.precision-Tuple{BiCM}" href="#Base.precision-Tuple{BiCM}"><code>Base.precision</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">precision(m::BiCM)</code></pre><p>Determine the compute precision of the BiCM model <code>m</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = BiCM(corporateclub());

julia&gt; MaxEntropyGraphs.precision(model)
Float64</code></pre><pre><code class="language-julia-repl hljs">julia&gt; model = BiCM(corporateclub(), precision=Float32);

julia&gt; MaxEntropyGraphs.precision(model)
Float32</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/f6ec80b8a47fdf63a799e4661aa808852612f818/src/Models/BiCM.jl#L507-L526">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.A-Tuple{BiCM, Int64, Int64}" href="#MaxEntropyGraphs.A-Tuple{BiCM, Int64, Int64}"><code>MaxEntropyGraphs.A</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">A(m::BiCM,i::Int,j::Int)</code></pre><p>Return the expected value of the <strong>biadjacency matrix</strong> for the BiCM model <code>m</code> at the node pair <code>(i,j)</code>.</p><p>❗ For perfomance reasons, the function does not check:</p><ul><li>if the node pair is valid.</li><li>if the parameters of the model have been computed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/f6ec80b8a47fdf63a799e4661aa808852612f818/src/Models/BiCM.jl#L818-L826">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.f_BiCM-Tuple{BiCM}" href="#MaxEntropyGraphs.f_BiCM-Tuple{BiCM}"><code>MaxEntropyGraphs.f_BiCM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">f_BiCM(x::T)</code></pre><p>Helper function for the BiCM model to compute the expected value of the biadjacency matrix. The function computes the expression <code>x / (1 + x)</code>. As an argument you need to pass the product of the maximum likelihood parameters <code>xᵣ[i] * yᵣ[j]</code> from a BiCM model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/f6ec80b8a47fdf63a799e4661aa808852612f818/src/Models/BiCM.jl#L810-L815">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.biadjacency_matrix" href="#MaxEntropyGraphs.biadjacency_matrix"><code>MaxEntropyGraphs.biadjacency_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">biadjacency_matrix(G::Graphs.SimpleGraph; skipchecks::Bool=false)</code></pre><p>Return the biadjacency matrix of the bipartite graph <code>G</code>.</p><p>If the graph is not bipartite, an error is thrown. If the adjacency matrix can be written as: A = [O B; B&#39; O] where O is the null matrix, then the returned biadjacency matrix is B and and B&#39; is the transposed biadjacency matrix.</p><p><strong>Arguments</strong></p><ul><li><code>skipchecks</code>: if true, skip the check for the graph being bipartite.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [0 0 0 0 1 0 0;
0 0 0 0 1 1 0;
0 0 0 0 0 0 1;
0 0 0 0 0 1 1;
1 1 0 0 0 0 0;
0 1 0 1 0 0 0;
0 0 1 1 0 0 0];

julia&gt; G = MaxEntropyGraphs.Graphs.SimpleGraph(A);

julia&gt; Array(biadjacency_matrix(A))
4x3 Matrix{Int64}:
 1  0  0
 1  1  0
 0  0  1
 0  1  1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/f6ec80b8a47fdf63a799e4661aa808852612f818/src/metrics.jl#L1117-L1149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MaxEntropyGraphs.project" href="#MaxEntropyGraphs.project"><code>MaxEntropyGraphs.project</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">project(G::Graphs.SimpleGraph;  membership::Vector=Graphs.bipartite_map(G), 
                                bottom::Vector=findall(membership .== 1), 
                                top::Vector=findall(membership .== 2); 
                                layer::Symbol=:bottom)</code></pre><p>Project the bipartite graph <code>G</code> onto one of its layers and return the projected graph.</p><p><strong>Arguments</strong></p><ul><li><code>membership</code>: the bipartite mapping of the graphs. This can be computed using <code>Graphs.bipartite_map(G)</code>.</li><li><code>bottom</code>: the nodes in the bottom layer. This can be computed using <code>findall(membership .== 1)</code>.</li><li><code>top</code>: the nodes in the top layer. This can be computed using <code>findall(membership .== 2)</code>.</li><li><code>layer</code>: the layer can be specified by passing <code>layer=:bottom</code> or <code>layer=:top</code>. Layer membership is determined by the bipartite map of the graph.</li><li><code>method</code>: the method used to compute the adjacency matrix of the projected graph. This can be <code>:simple</code> or <code>:weighted</code>. Both methods compute    the product of the biadjacency matrix with its transposed, but the <code>:weighted</code> method uses the weights of the edges in the projected graph.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Graphs

julia&gt; G = SimpleGraph(5); add_edge!(G, 1, 4); add_edge!(G, 2, 4); add_edge!(G, 3, 4); add_edge!(G, 3, 5);

julia&gt; project(G, layer=:bottom)
{3, 3} undirected simple Int64 graph
</code></pre><pre><code class="language-julia-repl hljs">julia&gt; project(G, layer=:top)
{2, 1} undirected simple Int64 graph
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/f6ec80b8a47fdf63a799e4661aa808852612f818/src/metrics.jl#L1162-L1194">source</a></section><section><div><pre><code class="language-julia hljs">project(B::T; layer::Symbol=:bottom, method::Symbol=:simple) where {T&lt;:AbstractMatrix}</code></pre><p>Project the biadjacency matrix <code>B</code> onto one of its layers.</p><p><strong>Arguments</strong></p><ul><li><code>layer</code>: the layer can be specified by passing <code>layer=:bottom</code> or <code>layer=:top</code>. Layer membership is determined by the bipartite map of the graph.</li><li><code>method</code>: the method used to compute the adjacency matrix of the projected graph. This can be <code>:simple</code> or <code>:weighted</code>. Both methods compute    the product of the biadjacency matrix with its transposed, but the <code>:weighted</code> method uses the weights of the edges in the projected graph.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; B = [0 0 0 1 1; 0 0 0 1 1; 0 0 0 1 0];

julia&gt; project(B, layer=:bottom)
3×3 Matrix{Bool}:
 0  1  1
 1  0  1
 1  1  0
</code></pre><pre><code class="language-julia-repl hljs">julia&gt; project(B, layer=:top)
5×5 Matrix{Bool}:
 0  0  0  0  0
 0  0  0  0  0
 0  0  0  0  0
 0  0  0  0  1
 0  0  0  1  0
</code></pre><pre><code class="language-julia-repl hljs">julia&gt; B = [0 0 0 1 1; 0 0 0 1 1; 0 0 0 1 0];

julia&gt; project(B, layer=:bottom, method=:weighted)
3×3 Matrix{Int64}:
 0  2  1
 2  0  1
 1  1  0
</code></pre><pre><code class="language-julia-repl hljs">julia&gt; project(B, layer=:top, method=:weighted)
5×5 Matrix{Int64}:
 0  0  0  0  0
 0  0  0  0  0
 0  0  0  0  0
 0  0  0  0  2
 0  0  0  2  0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/f6ec80b8a47fdf63a799e4661aa808852612f818/src/metrics.jl#L1234-L1286">source</a></section><section><div><pre><code class="language-julia hljs">project(m::BiCM;   α::Float64=0.05, layer::Symbol=:bottom, precomputed::Bool=true, 
                    distribution::Symbol=:Poisson, adjustment::PValueAdjustment=BenjaminiHochberg(),
                        multithreaded::Bool=false)</code></pre><p>Obtain the statistically validated projected graph of the BiCM model <code>m</code> onto the layer <code>layer</code> using the V-motifs and the significance level <code>α</code> combined with the p-value adjustment method <code>adjustment</code>.</p><p><strong>Arguments</strong></p><ul><li><code>α</code>: the significance level.</li><li><code>layer</code>: the layer can be specified by passing <code>layer=:bottom</code> or <code>layer=:top</code>.</li><li><code>precomputed</code>: if true, the expected values of the biadjacency matrix are used, otherwise the parameters are computed from the model parameters.</li><li><code>distribution</code>: the distribution used to compute the p-values. This can be <code>:Poisson</code> or <code>:PoissonBinomial</code>.</li><li><code>adjustment</code>: the method used to adjust the p-values for multiple testing. This can be any of the methods in the <code>PValueAdjustment</code> type (see <code>MultipleTesting.jl</code>). By default, the Benjamini-Hochberg method is used.</li><li><code>multithreaded</code>: if true, the p-values are computed using multithreading.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = BiCM(corporateclub());

julia&gt; solve_model!(model);

julia&gt; project(model, layer=:bottom)
{25, 0} undirected simple Int64 graph
</code></pre><pre><code class="language-julia-repl hljs">julia&gt; project(model, layer=:top)
{15, 0} undirected simple Int64 graph
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/B4rtDC/MaxEntropyGraphs.jl/blob/f6ec80b8a47fdf63a799e4661aa808852612f818/src/metrics.jl#L1697-L1727">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../API_DBCM/">« DBCM</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Friday 8 March 2024 13:24">Friday 8 March 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
